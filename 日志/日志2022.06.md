void *p 无类型指针

任何类型的指针都可以直接转换为void类型指针，无需强行转换





内存分区

![image-20220619173005718](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/06/upgit_20220619_1655631437.png)

```
text：代码区
	只读、共享
数据区：
	data：已初始化的静态/全局变量 数据区
	bss：未初始化的静态/全局变量 数据区
dec：程序的十进制大小
hex：程序的十六进制大小
filename：程序的名称
```

```
代码区、数据区(静态/全局数据)、堆区(heap)、栈区(stack)
```

栈区：由编译器分配与释放，存放函数的参数值、返回值、局部变量等；在程序运行时加载结束时释放；局部变量的生存周期为从申请到释放该段栈空间的时间。

堆区：用于动态内存分配，由程序员分配与释放，也会在结束程序时被操作系统回收。



全局静态区：全局区/静态区/常量区

全局变量与静态变量的区别在于**作用域**

常量区存放**字符串常量**和**const修饰的变量**，常量区的数据一旦初始化，就不能修改，常量所在的内存属于只读内存



**前置++**效率比**后置++**效率高，后置++会产生一个临时变量，没有特殊要求的情况下，优先使用**前置++**



变量定义时一定要初始化，



```c
#include <stdio.h>

// extern int a= 10;	默认是外部链接
int a = 10;		// 全局区
//静态全局变量是内部链接
static int b = 10;	//静态区

//内部链接和外部链接有什么区别？
//1.如果变量是内部链接的话，那么此变量只能在当前文件内访问
//2.如果是变量是外部链接的话，那么此变量可以被其他文件使用

//1.全局静态变量和局部静态变量都存储在静态区，都是在程序运行期间都是合法有效
//2.局部静态变量符号的可见范围仅限于当前函数内部，全局静态变量可见范围从定义到文件结尾
void test(){
    static int c = 10;	//静态区
}

main()
{
    test();
    return 0;
}
```

头文件不参与编译，每一个.c文件，我们叫做一个编译单元

编译器独立编译每一个.c文件

通过`extern`关键字声明位于其他文件中的全局变量，表示告诉`编译器`这个符号是存在的，你让我先编译通过，然后让`链接器`去找到底这个符号在哪

```c
//------------------extern.c-----------------------
#include <stdio.h>
#include <stdlib.h>
int a = 10;
static int b = 10;
void test(){
        extern int g_a;
        printf("通过extern访问全局变量g_a:%d\n", g_a);
}
int main()
{
        test();
        return 0;
}
//------------------extern02.c-----------------------
int g_a = 10;
```

```shell
# 编译
gcc extern.c -c -o extern.o
gcc extern02.c -c -o extern02.o
#链接
gcc -o extern extern.o extern02.o
#执行
./extern
#结果
通过extern访问全局变量g_a:10
```

**头文件里只放声明，不放编译**(只有函数或变量声明，没有函数定义或变量初始化)

```c
#include <stdio.h>
#include <stdlib.h>
const int g_c = 100;
// 常量区：字符串常量、全局const变量，存放在栈上
// 局部const变量存放在栈上
// const全局变量在常量区，不能修改（直接或者间接）
void test(){
        // g_c  = 10;
        int *p = (int *)&g_c;
        *p = 20;
}
int main()
{
        test();
        return 0;
}
```

可以通过编译，但运行时会出现**段错误**，因为`p`指向的内存是只读的，修改会出错

```c
#include <stdio.h>
#include <stdlib.h>
const int g_c = 100;
// 常量区：字符串常量、全局const变量，存放在栈上
// 局部const变量存放在栈上
// const全局变量在常量区，不能修改（直接或者间接）
void test(){
        // g_c  = 10;
        int *p = (int *)&g_c;
        *p = 20;
}
void test2(){
        const int b = 200;
        // b = 300; 错误，无法直接修改
        printf("b=%d \n",b);
        int *p = (int *)&b;
        *p = 400;	// 可以通过指针间接修改
        printf("b=%d \n",b);
}
int main()
{
        //test();
        test2();
        return 0;
}
```

```shell
gcc const.c -o const&& ./const   
b=200 
b=400 
```

字符串常量默认是`char *`类型

ANSI C中规定：修改字符串常量，结果是未定义的。一般情况下字符产常量是不可以修改的，不过默写编译器可以通过指针修改字符产常量。



数据区包括：堆，栈，全局/静态存储区。
全局/静态存储区包括：常量区，全局区、静态区。
常量区包括：字符串常量区、常变量区。
代码区：存放程序编译后的二进制代码，不可寻址区。
可以说，C/C++内存分区其实只有两个，即代码区和数据区。



1）预处理：宏定义展开、头文件展开、条件编译，这里并不会检查语法

2）编译：检查语法，将预处理后文件编译生成汇编文件

3）汇编：将汇编文件生成目标文件（二进制文件）
4）链接：将目标文件链接为可执行程序



**宏函数**

宏函数不是一个真正的函数

完整的函数包括：返回值、参数、函数体

宏函数在一定场景下效率比函数高

**函数的调用流程**

栈：先入先出的数据模型

在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将压入栈中的数据弹出（出栈，pop），但是栈容器必须遵循一条规则：先入栈的数据最后出栈（First In Last Out，FILO）.

宏函数没有普通函数调用的开销（函数压栈，跳转，返回等），但是需要牺牲空间



指针，不管几级指针、什么类型，都占四个字节的

野指针出现的情况：指针变量没有初始化、指针释放后没有置空、指针变量超过作用域

指针初始化时需要置空；再释放内存后需要置空



间接访问操作符*****，指针解引用后就直接把指针看作一块内存



`int * p=NULL`等效于`int * p=0`

### Windows使用时遇到的一点小问题-桌面/图标不自动刷新

**方法1：**

```
win+r 打开 运行
输入 regedit 打开注册表
展开 计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control
在 在Control项上右键选择新建“项”，将项的名称修改为“UPdata”
在刚新建的"UPdata"项上，再新建一个项，命名为“UpdateMode”
点击"UpdateMode"，然后在右侧窗口中，新建一个“可扩充字符串值”然后将数据名称改为“DWORD”;双击“DWORD”把值修改为0
重启电脑
```

**方法2**：

```
删除 \c\Users\用户名\AppData\Roaming\Microsoft\Windows\Recent 下的 AutomaticDestinations 文件夹
```

 

指针作函数参数的输入特性：

​	1、主调函数分配内存，被调函数使用内存



指针赋值的三个条件：

​	1、2个变量(一个普通变量，一个指针变量；或者一个实参，一个形参)

​	2、建立关系

​	3、通过 * 操作指针的内存

`calloc()`、`realloc()`


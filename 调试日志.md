# 2021.06.14
## 1、小乌龟控制

Terminal 1	启动内核
	roscore

Terminal 2	启动节点
	rosrun turtlesim turtlesim_node 

Terminal 3	键盘控制
	rosrun turtlesim turtle_teleop_key
## 2、Publisher与Subscriber
### (1)编写talker.cpp和listener.cpp
### (2)修改CMakeLists.txt

	include_directories( include ${catkin_INCLUDE_DIRS})
	add_executable(talker src/talker.cpp)
	target_link_libraries(talker ${catkin_LIBRARIES} )
	add_executable(listener src/listener.cpp)
	target_link_libraries(listener ${catkin_LIBRARIES} )
### (3)编译

	cd ~/test_ws
	catkin_make
### (4)运行

	T1	roscore
	T2	rosrun test_tutoials talker 
	T3	rosrun test_tutoials listener
## 3、自定义话题消息
### (1)创建msg文件夹、自定义消息Person.msg	
	$ mkdir ~/test_ws/src/test_tutoials/msg
	$ vim ~/test_ws/src/test_tutoials/msg/Person.msg
		string name
		uint8  sex
		uint8  age
	
		uint8 unknown = 0
		uint8 male    = 1
		uint8 female  = 2
### (2)修改package.xml和CMakeList.txt
	$ vim package.xml
		<build_depend>message_generation</build_depend>
		<exec_depend>message_runtime</exec_depend>  
	$ vim CMakeLists.txt 
		CATKIN_DEPENDS roscpp rospy std_msgs message_runtime
		#以下两条写在 catkin_package() 前面
		add_message_files(FILES Person.msg)
		generate_messages(DEPENDENCIES std_msgs)
### (3)rosmsg show Person 查看msg消息
## 4、自定义服务数据
### (1)创建srv文件
	$ mkdir ~/test_ws/src/test_tutoials/srv
	$ vim AddTwoInts.srv
	
		int64 a
		int64 b
		---
		int64 sum
### (2)修改package.xml和CMakeList.txt
	$ vim package.xml
		<build_depend>message_generation</build_depend>
		<exec_depend>message_runtime</exec_depend>
		之前已添加
	$ vim CMakeLists.txt
		find_package(catkin REQUIRED COMPONENTS roscpp rospystd_msgsstd_msgs message_generation)a
		add_service_files(FILES AddTwoInts.srv)
### (3)编译，生成相关头文件
## 5、服务
### (1)编写server.cpp和client.cpp
### (2)修改CMakeLists.txt
	add_executable(server src/server.cpp)
	target_link_libraries(server ${catkin_LIBRARIES})
	add_dependencies(server ${PROJECT_NAME}_gencpp)
	
	add_executable(client src/client .cpp)
	target_link_libraries(client ${catkin_LIBRARIES})
	add_dependencies(client ${PROJECT_NAME}_gencpp)
### (3)编译运行
---
# 2021.06.15
## vs code配置ROS环境
	https://zhuanlan.zhihu.com/p/365384185
	使用
	catkin_make -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=Yes
编译包，补全一些json文件
## 6、launch文件
### (1)<node>格式
	<node pkg="包名" type="启动文件名" name="节点名称" />(注：节点名称会替换init()函数定义的名字)
### (2)<param>ROS系统参数
	<param name="  " value="  " />
	<rosparam file=" " command="load" />
### (3)<arg>launch文件内部参数
	<arg name=" " value="  " />
### (4)<remap> 重映射
	<remap from="原话题" to="目标话题" />
### (5)<include> launch文件嵌套复用
	<include file="xxx.launch" />
## 7、TF变换
### (1)demo
	$ roslaunch turtle_tf turtle_tf_demo.launch #打开demo，出现两只小乌龟，turtle2跟随turtle1
	$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' #控制turtle1运动
	$ rosrun tf tf_echo turtle1 turtle2 #显示turtle1相对于turtle2的坐标
	$ rosrun rviz rviz -d `rospack find turtle_tf`/rviz/turtle_rviz.rviz	#在rviz上显示相对坐标
### (2)tf
	$ cd ~/test_ws/src
	$ catkin_create_pkg test_tf tf roscpp rospy turtlesim	#创建tf功能包
	$ cd ..
	$ catkin_make #初始化包
	$ vim ~/test_ws/src/test_tf/src/test_tf_broadcaster.cpp #创建广播器
	$ vim ~/test_ws/src/test_tf/src/test_tf_listener.cpp #创建监听器
	编辑CMakeList.txt
	编写launch文件
---
# 2021.06.17
## 8、ROS工具
	rqt_console 日志输出工具
	rqt_graph 计算图可视化工具
	rqt_plot 数据绘图工具
	rqt_reconfigure 参数动态配置工具
	rviz 三维可视化平台
	Gazebo仿真平台
	rosbag 数据记录于回放
## 9、vs code上的vim
https://www.ahonn.me/blog/the-vim-guide-for-vs-code-users
https://www.jianshu.com/p/1a7e9d07045c
## 10、tf frame
	编写frame_tf_broadcaster.cpp
## 11、在CMakeLists.txt中添加set命令
	set(CMAKE_EXPORT_COMPILE_COMMANDS ON)	#自动生成compile_commands.json文件
## 12、ROS官网教程 tf/Tutorials/Adding a frame (C++) 运行报错：
### [ERROR] [1623928661.694540605]: turtle2 passed to lookupTransform argument target_frame does not exist. 
### 解决办法：
	参考《ROS机器人开发实践》69页，try中添加 waitForTransform() 函数：
	listener.waitForTransform(/turtle2, /carrot1, ros::Time(0), ros::Duration(3.0)); 
## 13、建立软连接
	ln -s 原文件/文件夹的绝对地址 目标绝对地址
## 14、安装 edge dev linux 浏览器
### 安装下载工具 PyIDM
	$ sudo apt install python-pip python3-pip python3-tk xclip ffmpeg
	$ pip3 install pyIDM
## 15、history 指令
	history(选项)(参数)
		-N: 显示历史记录中最近的N个记录；#history 7
		-c：清空当前历史命令；
		-a：将历史命令缓冲区中命令写入历史命令文件中；
		-r：将历史命令文件中的命令读入当前历史命令缓冲区；
		-w：将当前历史命令缓冲区命令写入历史命令文件中;
		-d<offset>：删除历史记录中第offset个命令
		-n<filename>：读取指定文件
---
# 2021.06.18
	机器人电池没充上电，连夜跑，电池跑废
## 16、瞎折腾——VSCode美化
### 插件——Bracket Pair Colorizer——给匹配的括号着色
### 插件——Code Spell Checker——拼写检查器,忽略 日志
### 插件——TODO Highlight——TODO高亮显示
### 插件——Todo Tree——树状视图中显示TODO，貌似会严重占用CPU，目前在ubuntu上尚未发现，
		相关参数配置：
			https://zhuanlan.zhihu.com/p/63303926
			https://blog.csdn.net/wf19930209/article/details/109231743
		TODO ：代表未完成事项
		FIXME ：代表需要修复的事项
###	插件——A-super-translate——划词翻译
###	插件——Better Comments——添加彩色注释
---

# 2021.09.09
$S=2 \times \arcsin \left(\sqrt{\sin ^{2}\left(\frac{a}{2}\right)+\cos (L a t 1) \times \cos (l a t 2) \times \sin ^{2}\left(\frac{b}{2}\right)}\right) \times 6370996.81 (m)$


$a=Lat1-Lat2,b=lon1-lon2$



# 2021.09.10
添加订阅GPS数据的话题
- 创建包
```shell
cd ~/catkin_ws/src
catkin_create_pkg mygps std_msgs rospy roscpp sensor_msgs
cd ~/catkin_ws
catkin_make
```
- 创建脚本
```shell
cd ~/catkin_ws/src/mygps/
mkdir scripts
cd scripts
touch control.py
chmod +x control.py 
```
- 编辑脚本
```shell
vim control.py
```
```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-
import rospy
import math
import time

from std_msgs.msg import String
from sensor_msgs.msg import NavSatFix
from sensor_msgs.msg import NavSatStatus
from std_msgs.msg import Header

#回调函数输入的应该是msg
def callback(gps):
    # distance = math.sqrt(math.pow(gps.x, 2)+math.pow(gps.y, 2)) 
    rospy.loginfo('Listener: GPS: distance=%f distance=%f', gps.latitude, gps.longitude)

def listener():
    rospy.init_node('pylistener', anonymous=True)
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber('/gps/fix', NavSatFix, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()
```
- 安装requests，python2.7没有requests
```shell
sudo apt-get install python-requests
```
- 测试navigation2.0.py

```shell
python navigation2.0.py 
```
- 编写新的节点 control2.py
```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-
import math
from re import split
# import time
import json
import requests
# import datetime
# import sys
import rospy

from std_msgs.msg import String
from sensor_msgs.msg import NavSatFix
# from sensor_msgs.msg import NavSatStatus
# from std_msgs.msg import Header


pub = rospy.Publisher('deg_dis', String, queue_size=10)  #发布话题设为全局变量

###获取指定地点的经纬度，输入为某个地名
def get_location_x_y(place):
    #place = input("请输入您要查询的地址")
    url = 'https://restapi.amap.com/v3/geocode/geo?parameters'
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'address':'%s' % place
    }
    page_resource = requests.get(url,params=parameters)
    text = page_resource.text       #获得数据是json格式
    #print(text)
    data = json.loads(text)         #把数据变成字典格式

    location = data["geocodes"][0]['location']
    print(location)
    return location

#使用高德自带的坐标转换，将GPS坐标转换为gcj02坐标，返回 经度，纬度
def convert(lng, lat):
    url= 'https://restapi.amap.com/v3/assistant/coordinate/convert'
    location=str(lng)+','+str(lat)
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'locations':location,
        'coordsys':'gps'
    }
    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    # print(formatted_url)
    response = requests.get(formatted_url)
    text = response.text 
    data = json.loads(text)
    # print(data)
    location = data['locations']

    # location = location.split(',')
    # print(location)
    # print(location)
    return location

#路线规划，输入参数为起点和终点的经纬度，经纬度数据是gcj02坐标
def route_planning(lon1,lat1,lon2,lat2):
    from_location=str(lon1)+","+str(lat1)
    to_location=str(lon2)+","+str(lat2)

    #type = input("出行方式（1.公交、2.步行、3.驾车、4.骑行）,请输入数字")
    type = "2"
    url="https://restapi.amap.com"
    if type=="1":
        url = url+ "/v3/direction/transit/integrated"
    elif type=="2":
        url = url + "/v3/direction/walking"
    elif type=="3":
        url = url + "/v3/direction/driving"
    elif type == "4":
        url = url + "/v4/direction/bicycling"
    parameters = {
        'origin': from_location,
        'destination': to_location,
        'key': '2d3d0be8279d05e00314272bfa68734d',
        'extensions':'all',
        'output':'json',
    }

    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    response = requests.get(formatted_url)
    
    txt = json.loads(response.text)
    status = txt['status']
    status = int(status[0])
    if status == 0:
        return 0
    txt = txt['route']['paths'][0]['steps']
    info=[]
    j=0
    for i in txt:
        # i = i['instruction']
        i = i['polyline']
        info.append(j)
        j=j+1
        info.append(i)

    return info

#获取点2相对于点1的绝对角度，正北方向为0°，输入参数为两个点的经纬度
def get_degree(lon1,lat1,lon2,lat2):
    rad=3.1415926535897932384626/180
    
    #角度转弧度
    lat1=lat1*rad
    lon1=lon1*rad
    
    lat2=lat2*rad
    lon2=lon2*rad



    a = math.sin(lon2-lon1) * math.cos(lat2)
    b = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon2-lon1)
    
    result = math.atan2(a,b)/rad
    if result<0 :
        result += 360 
    return result

#获取两点之间的距离，单位 m ,输入参数为两个点的经纬度
def get_distance(lon1,lat1,lon2,lat2):
    """
    算法来源：http://developer.baidu.com/map/jsdemo.htm#a6_1
    :param pointA: {lat:29.490295, lng:106.486654}
    :param pointB: {lat:29.615467, lng:106.581515}
    :return:米
    """
    R = 6370996.81 #球半径

    if (lon1 and lat1 and lon2 and lat2):
        if lat1 == lat2 and lon1 == lon2:
            distance = 0
        else:
            a_lat = lat1 * math.pi / 180
            a_lng = lon1 * math.pi / 180
            b_lng = lon2 * math.pi / 180
            b_lat = lat2 * math.pi / 180
            # print(a_lng,b_lng,a_lat,b_lat)
            distance = R * math.acos(math.sin(a_lat) * math.sin(b_lat) + math.cos(a_lat) * math.cos(b_lat) * math.cos(b_lng - a_lng))
        return distance

#返回字符串数组，每个字符串包括 角度(°)和 距离(m),数据为整数
def datapath(info): 
    path=info[1].split(';') #获取第一条路径数据
    # path=info[7].split(';') #获取第一条路径数据
    #将数据分散
    lon=[]   #经度数据
    lat=[]   #纬度数据
    j=0
    while j < len(path):
        lon.append(float(path[j].split(',')[0]))
        lat.append(float(path[j].split(',')[1]))
        j += 1
    
    # print(lon, lat)
    # print(type(float(lon[0])))
    j=0
    data=[]
    thett=[]
    while j+1 < len(path):
        degree = int(get_degree(lon[j],lat[j],lon[j+1],lat[j+1]))
        thett.append(degree)
        # distance = int(get_distance(lon[j],lat[j],lon[j+1],lat[j+1]))
        distance = round(get_distance(lon[j],lat[j],lon[j+1],lat[j+1]), 2)
        # print(type(degree))
        # print(distance)
        data.append(str(degree)+","+str(distance))
        j += 1
    # print(type(data))
    newdata=''
    # print(len(data))
    j=0
    while j < len(data):
        # newdata = data[j] + ";"
        newdata = newdata+ ";" +str(data[j])
        j += 1
    newdata=newdata[1:]
    # print(newdata)
    # return data[0]
    return newdata

def out_of_china(lng, lat):
    """
    判断是否在国内，不在国内不做偏移
    :param lng:
    :param lat:
    :return:
    """
    return not (lng > 73.66 and lng < 135.05 and lat > 3.86 and lat < 53.55)
    

#回调函数输入的应该是msg
def callback(gps):
    # print(datetime.datetime.now())
    #经度longitude  纬度latitude
    rospy.loginfo('Header %s', gps.header.seq)
    
    #转换为gcj02坐标
    if out_of_china(gps.longitude, gps.latitude):
        the_location = convert(106.606024,29.532828)      
    else:
        the_location = convert(gps.longitude,gps.latitude)

    #使用 , 分割元素
    longitude=the_location.split(',')[0]
    latitude=the_location.split(',')[1]
    rospy.loginfo('Listener: GPS: %s %s', (longitude), (latitude))

    # longitude=106.606024
    # latitude=29.532828
    goal_longitude=106.6023346
    goal_latitude=29.5357341
    if gps.header.seq%5 == 0:
        # 获取路径
        # rospy.loginfo('ttmcc')
        info1 = route_planning(longitude,latitude,goal_longitude,goal_latitude)
        # info1 = route_planning(float(longitude),float(latitude),106.6023346,29.5357341)
        # print(float(longitude),float(latitude))
        # info1 = route_planning(106.606024,29.532828,106.6023346,29.5357341)
        # print(info1)
        # 计算角度和距离
        if info1==0 :
            Deg_Dis="666"   #高德地图没有规划路线
        else:
            Deg_Dis = datapath(info1)
        # print(Deg_Dis)
        # 发布角度和距离
        pub.publish(Deg_Dis)

    
    #获取角度与距离
    # info2 = datapath(info1)

    # print(info2)

def listener():
    rospy.init_node('pylistener', anonymous=True)
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber('/gps/fix', NavSatFix, callback)
    
    rospy.spin()

if __name__ == '__main__':
    listener()
```


# 2021.09.13

- 自定义发送的GPS消息类型
```shell
cd ~/gps_ws/src/mygps
mkdir msg
cd msg
touch myGPS.msg
```
- 编写myGPS.msg
```msg
uint16 state
uint32 deg
float64 dis
```
- 修改package.xml，添加以下内容
```xml
  <build_depend>message_generation</build_depend>
  <build_export_depend>message_generation</build_export_depend>
  <exec_depend>message_runtime</exec_depend>
```
- 修改CMakeLists.txt，为find_package添加message_generation

```xml
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  sensor_msgs
  std_msgs
  message_generation
)
```
- 修改CMakeLists.txt，找到add_message_files，添加myGPS.msg，取消generate_messages()的注释

```xml
 add_message_files(
   FILES
   myGPS.msg
 )

 generate_messages(
   DEPENDENCIES
   sensor_msgs#   
   std_msgs
 ) 
```
- 编译工作空间

```shell
roscd mygps/
cd ../..
catkin_make
```
- 查看msg信息

```shell
$ rosmsg show myGPS

[mygps/myGPS]:
uint16 state
uint32 deg
float64 dis
```
- 编写新脚本control4.py
```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-
import math
from re import split
import json
import requests
import rospy

from sensor_msgs.msg import NavSatFix
from mygps.msg import myGPS



pub = rospy.Publisher('deg_dis', myGPS, queue_size=10)  #发布话题设为全局变量
status = 0

###获取指定地点的经纬度，输入为某个地名
def get_location_x_y(place):
    #place = input("请输入您要查询的地址")
    url = 'https://restapi.amap.com/v3/geocode/geo?parameters'
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'address':'%s' % place
    }
    page_resource = requests.get(url,params=parameters)
    text = page_resource.text       #获得数据是json格式
    data = json.loads(text)         #把数据变成字典格式

    location = data["geocodes"][0]['location']
    print(location)
    return location

#使用高德自带的坐标转换，将GPS坐标转换为gcj02坐标，返回 经度，纬度
def convert(lng, lat):
    url= 'https://restapi.amap.com/v3/assistant/coordinate/convert'
    location=str(lng)+','+str(lat)
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'locations':location,
        'coordsys':'gps'
    }
    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    # print(formatted_url)
    response = requests.get(formatted_url)
    text = response.text 
    data = json.loads(text)
    location = data['locations']

    return location

#路线规划，输入参数为起点和终点的经纬度，经纬度数据是gcj02坐标
def route_planning(lon1,lat1,lon2,lat2):
    from_location=str(lon1)+","+str(lat1)
    to_location=str(lon2)+","+str(lat2)

    #type = input("出行方式（1.公交、2.步行、3.驾车、4.骑行）,请输入数字")
    type = "2"
    url="https://restapi.amap.com"
    if type=="1":
        url = url+ "/v3/direction/transit/integrated"
    elif type=="2":
        url = url + "/v3/direction/walking"
    elif type=="3":
        url = url + "/v3/direction/driving"
    elif type == "4":
        url = url + "/v4/direction/bicycling"
    parameters = {
        'origin': from_location,
        'destination': to_location,
        'key': '2d3d0be8279d05e00314272bfa68734d',
        'extensions':'all',
        'output':'json',
    }

    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    response = requests.get(formatted_url)
    print(formatted_url)
    txt = json.loads(response.text)

    global status 
    status = txt['status']

    status = int(status[0])
    print("status",status)
    if status == 0:
        status = 0
        return 

        print("第1个return已结束")

    elif 'route' not in txt:
        print("error")
        status = 3
        return 

        print("第2个return已结束")
    else:
        txt = txt['route']['paths'][0]['steps']
        info=[]
        j=0
        for i in txt:
            i = i['polyline']
            info.append(j)
            j=j+1
            info.append(i)

        print("第3个return之前已结束")
        status = 1
        return info

#获取点2相对于点1的绝对角度，正北方向为0°，输入参数为两个点的经纬度
def get_degree(lon1,lat1,lon2,lat2):
    rad=3.1415926535897932384626/180
    
    #角度转弧度
    lat1=lat1*rad
    lon1=lon1*rad
    
    lat2=lat2*rad
    lon2=lon2*rad
    
    a = math.sin(lon2-lon1) * math.cos(lat2)
    b = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon2-lon1)
    
    result = math.atan2(a,b)/rad
    if result<0 :
        result += 360 
    return result

#获取两点之间的距离，单位 m ,输入参数为两个点的经纬度
def get_distance(lon1,lat1,lon2,lat2):
    """
    算法来源：http://developer.baidu.com/map/jsdemo.htm#a6_1
    :param pointA: {lat:29.490295, lng:106.486654}
    :param pointB: {lat:29.615467, lng:106.581515}
    :return:米
    """
    R = 6370996.81 #球半径

    if (lon1 and lat1 and lon2 and lat2):
        if lat1 == lat2 and lon1 == lon2:
            distance = 0
        else:
            a_lat = lat1 * math.pi / 180
            a_lng = lon1 * math.pi / 180
            b_lng = lon2 * math.pi / 180
            b_lat = lat2 * math.pi / 180
            # print(a_lng,b_lng,a_lat,b_lat)
            distance = R * math.acos(math.sin(a_lat) * math.sin(b_lat) + math.cos(a_lat) * math.cos(b_lat) * math.cos(b_lng - a_lng))
        return distance

#返回字符串数组，每个字符串包括 角度(°)和 距离(m)
def datapath(info): 

    path=info[1].split(';') #获取第一条路径数据
    #将数据分散
    lon=[]   #经度数据
    lat=[]   #纬度数据
    j=0
    while j < len(path):
        lon.append(float(path[j].split(',')[0]))
        lat.append(float(path[j].split(',')[1]))
        j += 1

    j=0
    data=[]
 
    while j+1 < len(path):
        degree = int(get_degree(lon[j],lat[j],lon[j+1],lat[j+1]))
        distance = get_distance(lon[j],lat[j],lon[j+1],lat[j+1])
        data.append(str(degree)+","+str(distance))
        j += 1

    return data[0]

# 判断是否在国内   
def out_of_china(lng, lat):
    return not (lng > 73.66 and lng < 135.05 and lat > 3.86 and lat < 53.55)

# 判断是否连接互联网    
def isConnected():
    try:
        html = requests.get("http://www.baidu.com",timeout=2)
    except:
        return False
    return True

#回调函数输入的应该是msg
def callback(gps):
    #经度longitude  纬度latitude
    rospy.loginfo('Header %s', gps.header.seq)

    net_state = isConnected()

    if net_state == True:

        #转换为gcj02坐标
        if out_of_china(gps.longitude, gps.latitude):
            the_location = convert(106.606024,29.532828)      
        else:
            the_location = convert(gps.longitude,gps.latitude)    #转换为gcj02坐标


        #使用 , 分割元素
        longitude=the_location.split(',')[0]
        latitude=the_location.split(',')[1]
        rospy.loginfo('Listener: GPS: %s %s', (longitude), (latitude))

        # longitude=106.606024
        # latitude=29.532828
        goal_longitude=106.6023346
        goal_latitude=29.5357341

        if gps.header.seq%3 == 0:
            global status
            #info1 = route_planning(str(longitude),str(latitude),106.6023346,29.5357341)
            info1 = route_planning(longitude,latitude,goal_longitude,goal_latitude)
            print("status",status)
            msg = myGPS()
            if status != 1 :
                msg.state = status   # 0获取路径失败, 3没有具体的路径
                msg.deg = 0
                msg.dis = 0            
            elif status ==1 :
                Deg_Dis = datapath(info1)
                msg.state = 1
                msg.deg = int(Deg_Dis.split(',')[0])
                msg.dis = float(Deg_Dis.split(',')[1])
            # elif status ==3 :
            #     msg.state = 3   # 没有具体的路径
            #     msg.deg = 0
            #     msg.dis = 0 

            pub.publish(msg)
    elif net_state == False:
        rospy.loginfo('The network is not connected')
        msg = myGPS()
        msg.state = 2   # 网络连接失败
        msg.deg = 0
        msg.dis = 0
        pub.publish(msg)

def listener():
    rospy.init_node('pylistener', anonymous=True)
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber('/gps/fix', NavSatFix, callback)
    
    rospy.spin()

if __name__ == '__main__':
    listener()
```
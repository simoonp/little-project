# 2021.06.14
## 1、小乌龟控制

Terminal 1	启动内核
	roscore

Terminal 2	启动节点
	rosrun turtlesim turtlesim_node 

Terminal 3	键盘控制
	rosrun turtlesim turtle_teleop_key
## 2、Publisher与Subscriber
### (1)编写talker.cpp和listener.cpp
### (2)修改CMakeLists.txt

	include_directories( include ${catkin_INCLUDE_DIRS})
	add_executable(talker src/talker.cpp)
	target_link_libraries(talker ${catkin_LIBRARIES} )
	add_executable(listener src/listener.cpp)
	target_link_libraries(listener ${catkin_LIBRARIES} )
### (3)编译

	cd ~/test_ws
	catkin_make
### (4)运行

	T1	roscore
	T2	rosrun test_tutoials talker 
	T3	rosrun test_tutoials listener
## 3、自定义话题消息
### (1)创建msg文件夹、自定义消息Person.msg	
	$ mkdir ~/test_ws/src/test_tutoials/msg
	$ vim ~/test_ws/src/test_tutoials/msg/Person.msg
		string name
		uint8  sex
		uint8  age
	
		uint8 unknown = 0
		uint8 male    = 1
		uint8 female  = 2
### (2)修改package.xml和CMakeList.txt
	$ vim package.xml
		<build_depend>message_generation</build_depend>
		<exec_depend>message_runtime</exec_depend>  
	$ vim CMakeLists.txt 
		CATKIN_DEPENDS roscpp rospy std_msgs message_runtime
		#以下两条写在 catkin_package() 前面
		add_message_files(FILES Person.msg)
		generate_messages(DEPENDENCIES std_msgs)
### (3)rosmsg show Person 查看msg消息
## 4、自定义服务数据
### (1)创建srv文件
	$ mkdir ~/test_ws/src/test_tutoials/srv
	$ vim AddTwoInts.srv
	
		int64 a
		int64 b
		---
		int64 sum
### (2)修改package.xml和CMakeList.txt
	$ vim package.xml
		<build_depend>message_generation</build_depend>
		<exec_depend>message_runtime</exec_depend>
		之前已添加
	$ vim CMakeLists.txt
		find_package(catkin REQUIRED COMPONENTS roscpp rospystd_msgsstd_msgs message_generation)a
		add_service_files(FILES AddTwoInts.srv)
### (3)编译，生成相关头文件
## 5、服务
### (1)编写server.cpp和client.cpp
### (2)修改CMakeLists.txt
	add_executable(server src/server.cpp)
	target_link_libraries(server ${catkin_LIBRARIES})
	add_dependencies(server ${PROJECT_NAME}_gencpp)
	
	add_executable(client src/client .cpp)
	target_link_libraries(client ${catkin_LIBRARIES})
	add_dependencies(client ${PROJECT_NAME}_gencpp)
### (3)编译运行
---
# 2021.06.15
## vs code配置ROS环境
	https://zhuanlan.zhihu.com/p/365384185
	使用
	catkin_make -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=Yes
编译包，补全一些json文件
## 6、launch文件
### (1)<node>格式
	<node pkg="包名" type="启动文件名" name="节点名称" />(注：节点名称会替换init()函数定义的名字)
### (2)<param>ROS系统参数
	<param name="  " value="  " />
	<rosparam file=" " command="load" />
### (3)<arg>launch文件内部参数
	<arg name=" " value="  " />
### (4)<remap> 重映射
	<remap from="原话题" to="目标话题" />
### (5)<include> launch文件嵌套复用
	<include file="xxx.launch" />
## 7、TF变换
### (1)demo
	$ roslaunch turtle_tf turtle_tf_demo.launch #打开demo，出现两只小乌龟，turtle2跟随turtle1
	$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' #控制turtle1运动
	$ rosrun tf tf_echo turtle1 turtle2 #显示turtle1相对于turtle2的坐标
	$ rosrun rviz rviz -d `rospack find turtle_tf`/rviz/turtle_rviz.rviz	#在rviz上显示相对坐标
### (2)tf
	$ cd ~/test_ws/src
	$ catkin_create_pkg test_tf tf roscpp rospy turtlesim	#创建tf功能包
	$ cd ..
	$ catkin_make #初始化包
	$ vim ~/test_ws/src/test_tf/src/test_tf_broadcaster.cpp #创建广播器
	$ vim ~/test_ws/src/test_tf/src/test_tf_listener.cpp #创建监听器
	编辑CMakeList.txt
	编写launch文件
---
# 2021.06.17
## 8、ROS工具
	rqt_console 日志输出工具
	rqt_graph 计算图可视化工具
	rqt_plot 数据绘图工具
	rqt_reconfigure 参数动态配置工具
	rviz 三维可视化平台
	Gazebo仿真平台
	rosbag 数据记录于回放
## 9、vs code上的vim
https://www.ahonn.me/blog/the-vim-guide-for-vs-code-users
https://www.jianshu.com/p/1a7e9d07045c
## 10、tf frame
	编写frame_tf_broadcaster.cpp
## 11、在CMakeLists.txt中添加set命令
	set(CMAKE_EXPORT_COMPILE_COMMANDS ON)	#自动生成compile_commands.json文件
## 12、ROS官网教程 tf/Tutorials/Adding a frame (C++) 运行报错：
- [ERROR] [1623928661.694540605]: turtle2 passed to lookupTransform argument target_frame does not exist. 

- 解决办法：

	参考《ROS机器人开发实践》69页，try中添加 waitForTransform() 函数：
	listener.waitForTransform(/turtle2, /carrot1, ros::Time(0), ros::Duration(3.0)); 
## 13、建立软连接
	ln -s 原文件/文件夹的绝对地址 目标绝对地址
## 14、安装 edge dev linux 浏览器
### 安装下载工具 PyIDM
	$ sudo apt install python-pip python3-pip python3-tk xclip ffmpeg
	$ pip3 install pyIDM
## 15、history 指令
	history(选项)(参数)
		-N: 显示历史记录中最近的N个记录；#history 7
		-c：清空当前历史命令；
		-a：将历史命令缓冲区中命令写入历史命令文件中；
		-r：将历史命令文件中的命令读入当前历史命令缓冲区；
		-w：将当前历史命令缓冲区命令写入历史命令文件中;
		-d<offset>：删除历史记录中第offset个命令
		-n<filename>：读取指定文件
---
# 2021.06.18
	机器人电池没充上电，连夜跑，电池跑废
## 16、瞎折腾——VSCode美化
- 插件——Bracket Pair Colorizer——给匹配的括号着色
- 插件——Code Spell Checker——拼写检查器,忽略 日志
- 插件——TODO Highlight——TODO高亮显示
- 插件——Todo Tree——树状视图中显示TODO，貌似会严重占用CPU，目前在ubuntu上尚未发现，
		相关参数配置：
			https://zhuanlan.zhihu.com/p/63303926
			https://blog.csdn.net/wf19930209/article/details/109231743
		TODO ：代表未完成事项
		FIXME ：代表需要修复的事项
-	插件——A-super-translate——划词翻译
-	插件——Better Comments——添加彩色注释
---

# 2021.09.09
$S=2 \times \arcsin \left(\sqrt{\sin ^{2}\left(\frac{a}{2}\right)+\cos (L a t 1) \times \cos (l a t 2) \times \sin ^{2}\left(\frac{b}{2}\right)}\right) \times 6370996.81 (m)$


$a=Lat1-Lat2,b=lon1-lon2$



# 2021.09.10
添加订阅GPS数据的话题
- 创建包
```shell
cd ~/catkin_ws/src
catkin_create_pkg mygps std_msgs rospy roscpp sensor_msgs
cd ~/catkin_ws
catkin_make
```
- 创建脚本
```shell
cd ~/catkin_ws/src/mygps/
mkdir scripts
cd scripts
touch control.py
chmod +x control.py 
```
- 编辑脚本
```shell
vim control.py
```
```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-
import rospy
import math
import time

from std_msgs.msg import String
from sensor_msgs.msg import NavSatFix
from sensor_msgs.msg import NavSatStatus
from std_msgs.msg import Header

#回调函数输入的应该是msg
def callback(gps):
    # distance = math.sqrt(math.pow(gps.x, 2)+math.pow(gps.y, 2)) 
    rospy.loginfo('Listener: GPS: distance=%f distance=%f', gps.latitude, gps.longitude)

def listener():
    rospy.init_node('pylistener', anonymous=True)
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber('/gps/fix', NavSatFix, callback)
    rospy.spin()

if __name__ == '__main__':
    listener()
```
- 安装requests，python2.7没有requests
```shell
sudo apt-get install python-requests
```
- 测试navigation2.0.py

```shell
python navigation2.0.py 
```
- 编写新的节点 control2.py
```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-
import math
from re import split
# import time
import json
import requests
# import datetime
# import sys
import rospy

from std_msgs.msg import String
from sensor_msgs.msg import NavSatFix
# from sensor_msgs.msg import NavSatStatus
# from std_msgs.msg import Header


pub = rospy.Publisher('deg_dis', String, queue_size=10)  #发布话题设为全局变量

###获取指定地点的经纬度，输入为某个地名
def get_location_x_y(place):
    #place = input("请输入您要查询的地址")
    url = 'https://restapi.amap.com/v3/geocode/geo?parameters'
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'address':'%s' % place
    }
    page_resource = requests.get(url,params=parameters)
    text = page_resource.text       #获得数据是json格式
    #print(text)
    data = json.loads(text)         #把数据变成字典格式

    location = data["geocodes"][0]['location']
    print(location)
    return location

#使用高德自带的坐标转换，将GPS坐标转换为gcj02坐标，返回 经度，纬度
def convert(lng, lat):
    url= 'https://restapi.amap.com/v3/assistant/coordinate/convert'
    location=str(lng)+','+str(lat)
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'locations':location,
        'coordsys':'gps'
    }
    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    # print(formatted_url)
    response = requests.get(formatted_url)
    text = response.text 
    data = json.loads(text)
    # print(data)
    location = data['locations']

    # location = location.split(',')
    # print(location)
    # print(location)
    return location

#路线规划，输入参数为起点和终点的经纬度，经纬度数据是gcj02坐标
def route_planning(lon1,lat1,lon2,lat2):
    from_location=str(lon1)+","+str(lat1)
    to_location=str(lon2)+","+str(lat2)

    #type = input("出行方式（1.公交、2.步行、3.驾车、4.骑行）,请输入数字")
    type = "2"
    url="https://restapi.amap.com"
    if type=="1":
        url = url+ "/v3/direction/transit/integrated"
    elif type=="2":
        url = url + "/v3/direction/walking"
    elif type=="3":
        url = url + "/v3/direction/driving"
    elif type == "4":
        url = url + "/v4/direction/bicycling"
    parameters = {
        'origin': from_location,
        'destination': to_location,
        'key': '2d3d0be8279d05e00314272bfa68734d',
        'extensions':'all',
        'output':'json',
    }

    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    response = requests.get(formatted_url)
    
    txt = json.loads(response.text)
    status = txt['status']
    status = int(status[0])
    if status == 0:
        return 0
    txt = txt['route']['paths'][0]['steps']
    info=[]
    j=0
    for i in txt:
        # i = i['instruction']
        i = i['polyline']
        info.append(j)
        j=j+1
        info.append(i)

    return info

#获取点2相对于点1的绝对角度，正北方向为0°，输入参数为两个点的经纬度
def get_degree(lon1,lat1,lon2,lat2):
    rad=3.1415926535897932384626/180
    
    #角度转弧度
    lat1=lat1*rad
    lon1=lon1*rad
    
    lat2=lat2*rad
    lon2=lon2*rad



    a = math.sin(lon2-lon1) * math.cos(lat2)
    b = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon2-lon1)
    
    result = math.atan2(a,b)/rad
    if result<0 :
        result += 360 
    return result

#获取两点之间的距离，单位 m ,输入参数为两个点的经纬度
def get_distance(lon1,lat1,lon2,lat2):
    """
    算法来源：http://developer.baidu.com/map/jsdemo.htm#a6_1
    :param pointA: {lat:29.490295, lng:106.486654}
    :param pointB: {lat:29.615467, lng:106.581515}
    :return:米
    """
    R = 6370996.81 #球半径

    if (lon1 and lat1 and lon2 and lat2):
        if lat1 == lat2 and lon1 == lon2:
            distance = 0
        else:
            a_lat = lat1 * math.pi / 180
            a_lng = lon1 * math.pi / 180
            b_lng = lon2 * math.pi / 180
            b_lat = lat2 * math.pi / 180
            # print(a_lng,b_lng,a_lat,b_lat)
            distance = R * math.acos(math.sin(a_lat) * math.sin(b_lat) + math.cos(a_lat) * math.cos(b_lat) * math.cos(b_lng - a_lng))
        return distance

#返回字符串数组，每个字符串包括 角度(°)和 距离(m),数据为整数
def datapath(info): 
    path=info[1].split(';') #获取第一条路径数据
    # path=info[7].split(';') #获取第一条路径数据
    #将数据分散
    lon=[]   #经度数据
    lat=[]   #纬度数据
    j=0
    while j < len(path):
        lon.append(float(path[j].split(',')[0]))
        lat.append(float(path[j].split(',')[1]))
        j += 1
    
    # print(lon, lat)
    # print(type(float(lon[0])))
    j=0
    data=[]
    thett=[]
    while j+1 < len(path):
        degree = int(get_degree(lon[j],lat[j],lon[j+1],lat[j+1]))
        thett.append(degree)
        # distance = int(get_distance(lon[j],lat[j],lon[j+1],lat[j+1]))
        distance = round(get_distance(lon[j],lat[j],lon[j+1],lat[j+1]), 2)
        # print(type(degree))
        # print(distance)
        data.append(str(degree)+","+str(distance))
        j += 1
    # print(type(data))
    newdata=''
    # print(len(data))
    j=0
    while j < len(data):
        # newdata = data[j] + ";"
        newdata = newdata+ ";" +str(data[j])
        j += 1
    newdata=newdata[1:]
    # print(newdata)
    # return data[0]
    return newdata

def out_of_china(lng, lat):
    """
    判断是否在国内，不在国内不做偏移
    :param lng:
    :param lat:
    :return:
    """
    return not (lng > 73.66 and lng < 135.05 and lat > 3.86 and lat < 53.55)
    

#回调函数输入的应该是msg
def callback(gps):
    # print(datetime.datetime.now())
    #经度longitude  纬度latitude
    rospy.loginfo('Header %s', gps.header.seq)
    
    #转换为gcj02坐标
    if out_of_china(gps.longitude, gps.latitude):
        the_location = convert(106.606024,29.532828)      
    else:
        the_location = convert(gps.longitude,gps.latitude)

    #使用 , 分割元素
    longitude=the_location.split(',')[0]
    latitude=the_location.split(',')[1]
    rospy.loginfo('Listener: GPS: %s %s', (longitude), (latitude))

    # longitude=106.606024
    # latitude=29.532828
    goal_longitude=106.6023346
    goal_latitude=29.5357341
    if gps.header.seq%5 == 0:
        # 获取路径
        # rospy.loginfo('ttmcc')
        info1 = route_planning(longitude,latitude,goal_longitude,goal_latitude)
        # info1 = route_planning(float(longitude),float(latitude),106.6023346,29.5357341)
        # print(float(longitude),float(latitude))
        # info1 = route_planning(106.606024,29.532828,106.6023346,29.5357341)
        # print(info1)
        # 计算角度和距离
        if info1==0 :
            Deg_Dis="666"   #高德地图没有规划路线
        else:
            Deg_Dis = datapath(info1)
        # print(Deg_Dis)
        # 发布角度和距离
        pub.publish(Deg_Dis)

    
    #获取角度与距离
    # info2 = datapath(info1)

    # print(info2)

def listener():
    rospy.init_node('pylistener', anonymous=True)
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber('/gps/fix', NavSatFix, callback)
    
    rospy.spin()

if __name__ == '__main__':
    listener()
```


# 2021.09.13

- 自定义发送的GPS消息类型
```shell
cd ~/gps_ws/src/mygps
mkdir msg
cd msg
touch myGPS.msg
```
- 编写myGPS.msg
```msg
uint16 state
uint32 deg
float64 dis
```
- 修改package.xml，添加以下内容
```xml
  <build_depend>message_generation</build_depend>
  <build_export_depend>message_generation</build_export_depend>
  <exec_depend>message_runtime</exec_depend>
```
- 修改CMakeLists.txt，为find_package添加message_generation

```xml
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  sensor_msgs
  std_msgs
  message_generation
)
```
- 修改CMakeLists.txt，找到add_message_files，添加myGPS.msg，取消generate_messages()的注释

```xml
 add_message_files(
   FILES
   myGPS.msg
 )

 generate_messages(
   DEPENDENCIES
   sensor_msgs#   
   std_msgs
 ) 
```
- 编译工作空间

```shell
roscd mygps/
cd ../..
catkin_make
```
- 查看msg信息

```shell
$ rosmsg show myGPS

[mygps/myGPS]:
uint16 state
uint32 deg
float64 dis
```
- 编写新脚本control4.py
```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-
import math
from re import split
import json
import requests
import rospy

from sensor_msgs.msg import NavSatFix
from mygps.msg import myGPS



pub = rospy.Publisher('deg_dis', myGPS, queue_size=10)  #发布话题设为全局变量
status = 0

###获取指定地点的经纬度，输入为某个地名
def get_location_x_y(place):
    #place = input("请输入您要查询的地址")
    url = 'https://restapi.amap.com/v3/geocode/geo?parameters'
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'address':'%s' % place
    }
    page_resource = requests.get(url,params=parameters)
    text = page_resource.text       #获得数据是json格式
    data = json.loads(text)         #把数据变成字典格式

    location = data["geocodes"][0]['location']
    print(location)
    return location

#使用高德自带的坐标转换，将GPS坐标转换为gcj02坐标，返回 经度，纬度
def convert(lng, lat):
    url= 'https://restapi.amap.com/v3/assistant/coordinate/convert'
    location=str(lng)+','+str(lat)
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'locations':location,
        'coordsys':'gps'
    }
    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    # print(formatted_url)
    response = requests.get(formatted_url)
    text = response.text 
    data = json.loads(text)
    location = data['locations']

    return location

#路线规划，输入参数为起点和终点的经纬度，经纬度数据是gcj02坐标
def route_planning(lon1,lat1,lon2,lat2):
    from_location=str(lon1)+","+str(lat1)
    to_location=str(lon2)+","+str(lat2)

    #type = input("出行方式（1.公交、2.步行、3.驾车、4.骑行）,请输入数字")
    type = "2"
    url="https://restapi.amap.com"
    if type=="1":
        url = url+ "/v3/direction/transit/integrated"
    elif type=="2":
        url = url + "/v3/direction/walking"
    elif type=="3":
        url = url + "/v3/direction/driving"
    elif type == "4":
        url = url + "/v4/direction/bicycling"
    parameters = {
        'origin': from_location,
        'destination': to_location,
        'key': '2d3d0be8279d05e00314272bfa68734d',
        'extensions':'all',
        'output':'json',
    }

    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    response = requests.get(formatted_url)
    print(formatted_url)
    txt = json.loads(response.text)

    global status 
    status = txt['status']

    status = int(status[0])
    print("status",status)
    if status == 0:
        status = 0
        return 

        print("第1个return已结束")

    elif 'route' not in txt:
        print("error")
        status = 3
        return 

        print("第2个return已结束")
    else:
        txt = txt['route']['paths'][0]['steps']
        info=[]
        j=0
        for i in txt:
            i = i['polyline']
            info.append(j)
            j=j+1
            info.append(i)

        print("第3个return之前已结束")
        status = 1
        return info

#获取点2相对于点1的绝对角度，正北方向为0°，输入参数为两个点的经纬度
def get_degree(lon1,lat1,lon2,lat2):
    rad=3.1415926535897932384626/180
    
    #角度转弧度
    lat1=lat1*rad
    lon1=lon1*rad
    
    lat2=lat2*rad
    lon2=lon2*rad
    
    a = math.sin(lon2-lon1) * math.cos(lat2)
    b = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon2-lon1)
    
    result = math.atan2(a,b)/rad
    if result<0 :
        result += 360 
    return result

#获取两点之间的距离，单位 m ,输入参数为两个点的经纬度
def get_distance(lon1,lat1,lon2,lat2):
    """
    算法来源：http://developer.baidu.com/map/jsdemo.htm#a6_1
    :param pointA: {lat:29.490295, lng:106.486654}
    :param pointB: {lat:29.615467, lng:106.581515}
    :return:米
    """
    R = 6370996.81 #球半径

    if (lon1 and lat1 and lon2 and lat2):
        if lat1 == lat2 and lon1 == lon2:
            distance = 0
        else:
            a_lat = lat1 * math.pi / 180
            a_lng = lon1 * math.pi / 180
            b_lng = lon2 * math.pi / 180
            b_lat = lat2 * math.pi / 180
            # print(a_lng,b_lng,a_lat,b_lat)
            distance = R * math.acos(math.sin(a_lat) * math.sin(b_lat) + math.cos(a_lat) * math.cos(b_lat) * math.cos(b_lng - a_lng))
        return distance

#返回字符串数组，每个字符串包括 角度(°)和 距离(m)
def datapath(info): 

    path=info[1].split(';') #获取第一条路径数据
    #将数据分散
    lon=[]   #经度数据
    lat=[]   #纬度数据
    j=0
    while j < len(path):
        lon.append(float(path[j].split(',')[0]))
        lat.append(float(path[j].split(',')[1]))
        j += 1

    j=0
    data=[]
 
    while j+1 < len(path):
        degree = int(get_degree(lon[j],lat[j],lon[j+1],lat[j+1]))
        distance = get_distance(lon[j],lat[j],lon[j+1],lat[j+1])
        data.append(str(degree)+","+str(distance))
        j += 1

    return data[0]

# 判断是否在国内   
def out_of_china(lng, lat):
    return not (lng > 73.66 and lng < 135.05 and lat > 3.86 and lat < 53.55)

# 判断是否连接互联网    
def isConnected():
    try:
        html = requests.get("http://www.baidu.com",timeout=2)
    except:
        return False
    return True

#回调函数输入的应该是msg
def callback(gps):
    #经度longitude  纬度latitude
    rospy.loginfo('Header %s', gps.header.seq)

    net_state = isConnected()

    if net_state == True:

        #转换为gcj02坐标
        if out_of_china(gps.longitude, gps.latitude):
            the_location = convert(106.606024,29.532828)      
        else:
            the_location = convert(gps.longitude,gps.latitude)    #转换为gcj02坐标


        #使用 , 分割元素
        longitude=the_location.split(',')[0]
        latitude=the_location.split(',')[1]
        rospy.loginfo('Listener: GPS: %s %s', (longitude), (latitude))

        # longitude=106.606024
        # latitude=29.532828
        goal_longitude=106.6023346
        goal_latitude=29.5357341

        if gps.header.seq%3 == 0:
            global status
            #info1 = route_planning(str(longitude),str(latitude),106.6023346,29.5357341)
            info1 = route_planning(longitude,latitude,goal_longitude,goal_latitude)
            print("status",status)
            msg = myGPS()
            if status != 1 :
                msg.state = status   # 0获取路径失败, 3没有具体的路径
                msg.deg = 0
                msg.dis = 0            
            elif status ==1 :
                Deg_Dis = datapath(info1)
                msg.state = 1
                msg.deg = int(Deg_Dis.split(',')[0])
                msg.dis = float(Deg_Dis.split(',')[1])
            # elif status ==3 :
            #     msg.state = 3   # 没有具体的路径
            #     msg.deg = 0
            #     msg.dis = 0 

            pub.publish(msg)
    elif net_state == False:
        rospy.loginfo('The network is not connected')
        msg = myGPS()
        msg.state = 2   # 网络连接失败
        msg.deg = 0
        msg.dis = 0
        pub.publish(msg)

def listener():
    rospy.init_node('pylistener', anonymous=True)
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    rospy.Subscriber('/gps/fix', NavSatFix, callback)
    
    rospy.spin()

if __name__ == '__main__':
    listener()
```

# 2021.09.17
- 在myGPS.msg文件中添加 uint32 compass ，重新编译 

- 编写串口获取脚本 myserial.py，

话题名称：/myserial

消息类型：/Float32

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
import rospy
import time
import serial #导入serial包
# from std_msgs.msg import String
from std_msgs.msg import Float32

#pub = rospy.Publisher('myserial', String , queue_size=5)  #发布话题设为全局变量
pub = rospy.Publisher('myserial', Float32 , queue_size=5)  #发布话题设为全局变量

def node():
    rospy.init_node("serial_test") #初始化ros节点
    ser = serial.Serial("/dev/ttyUSB0", 9600, timeout=1) #打开串口, 端口号:"/dev/ttyUSB0". 波特率:9600. 延时等待1s
    if ser.isOpen(): #判断串口是否打开
        print("串口打开成功")
    else:
        print("串口打开失败")
        quit()
    while not rospy.is_shutdown():
        ser.write('hello')#发送hello
        time.sleep(1)#等待1s
        cnt = ser.inWaiting() #等待接受数据
        if cnt > 0 : #接受数据量大于0
            rev = ser.read(cnt) #读数据
            print(rev)
            # print(type(rev))
            Magx=rev.split(',')[0]
            Magy=rev.split(',')[1]
            Magz=rev.split(',')[2]
            Yaw =rev.split(',')[3]
            # print(str(rev)) #打印
            # rev = rev.split(',')[3]
            # rev = rev.split(':')[1]
            Magx= Magx.split(':')[1]
            Magy= Magy.split(':')[1]
            Magz= Magz.split(':')[1]
            Yaw = Yaw.split(':')[1]
            # Yaw = Yaw.split('\\')[0]
            print("Magx:",Magx, " Magy:", Magy, " Magz:", Magz, " Yaw: ", Yaw)
            
            Yaw = float(Yaw)
            print(Yaw)
            print(type((Yaw)))
            #pub.publish(String(rev))
            pub.publish(Yaw)
if __name__ == '__main__':
    try:
        node()
    except rospy.ROSInterruptException:
        pass
    # node()
```

在另外一个py文件中添加：

- 导入消息类型：
```python
from std_msgs.msg import Float64
```
- 添加全局变量
```python
serialdata = 0
```
- listener()函数中添加

```python
rospy.Subscriber('/myserial', Float64, callback2)
```
- 添加回调函数callback2()
```python
def callback2(myserial):
    global serialdata
    serialdata=myserial.data
    rospy.loginfo('------------------Listener: serial=%f ', serialdata)
```
- 每个pub.publish(msg)前面添加：

```python
global serialdata
msg.compass=serialdata
```

查看USB设备的详细信息
```shell
$ lsusb
Bus 002 Device 003: ID 0bc2:231a Seagate RSS LLC 
Bus 002 Device 002: ID 0bda:0411 Realtek Semiconductor Corp. 
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 012: ID 8087:0029 Intel Corp. 
Bus 001 Device 015: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapter
Bus 001 Device 003: ID 0bda:5411 Realtek Semiconductor Corp. 
Bus 001 Device 006: ID 05e3:0608 Genesys Logic, Inc. Hub
Bus 001 Device 009: ID 18f8:1286  
Bus 001 Device 007: ID 413c:2113 Dell Computer Corp. 
Bus 001 Device 004: ID 3188:6804  
Bus 001 Device 002: ID 05e3:0608 Genesys Logic, Inc. Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

或者
```shell
udevadm info --attribute-walk --name=/dev/ttyUSB0
```

| Bus 001 | Device 015 | : | ID 1a86:7523 | QinHeng Electronics|HL-340 USB-Serial adapter |
| ------- | ---------- | ---- | ------------ | ----------------------------|----------------- |
| 第1个usb主控制器|系统分配的设备号|      |usb设备的ID，idVendor和idProduct，由芯片制造商设置，可以唯一表示该设备|idVendo|idProduct|

udev规则文件

udev的规则文件一般位于 /lib/udev/rules.d/，也可以位于 /etc/udev/rules.d/
规则文件是按照字母顺序处理的，不管放在哪个目录。对于相同名字的规则文件， /etc/udev/rules.d 比 /lib/udev/rules.d 优先。
规则文件必须以 .rules 作为扩展名，否则不被当作规则文件。
规则文件的每一行都是 key=value 格式。 key 有两个类型：1）匹配型 key  2）赋值型 key
当所有匹配型 key 都匹配时，该规则即被采用，赋值型 key 就会获得相应的值。
当规则匹配时，可以重命名网络接口， 创建到设备节点的符号链或运行一个指定程序来处理该事件。
一条规则由多个key=value 组成，以英文逗号隔开。 每个 key 有一个操作，取决于操作符，有效的操作符如下：

```
           ==      比较是否相等
           !=       比较是否不相等
           =        给一个key 赋值。 表示一个列表的key会被重置，并且把这个唯一的值传给它
           +=     将一个值增加到key中
           :=      将一个值传给一个key，并且不允许再修改这个key。
```

```shell
KERNEL=="ttyACM*", ATTRS{idVendor}=="1546", ATTRS{idProduct}=="01a8", MODE:="0777", SYMLINK+="gps"
```


|关键词|含义|
|---|------|
|KERNEL|匹配事件的设备名|
|ATTR { filename }|匹配事件设备的 sysfs 属性|
|OWNER, GROUP, MODE|为设备设定权限|
|SYMLINK|为 /dev/下的设备文件产生符号链接。由于 udev 只能为某个设备产生一个设备文件，所以为了不覆盖系统默认的 udev 规则所产生的文件，推荐使用符号链接。|

为磁力计添加rule规则

```shell
$ sudo su
$  vim /etc/udev/rules.d/compass.rules
#加入以下内容
KERNEL=="ttyUSB*", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", MODE:="0777", SYMLINK+="compass" 
#上述内容好像有问题，改为以下内容：
KERNEL=="ttyUSB*", SUBSYSTEMS=="usb", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", MODE:="0777", SYMLINK+="compass" 
```

重新加载udev

```shell
$ sudo service udev reload
```

重启udev

```shell
$ sudo service udev restart
```

# 2021.09.18

ublox_gps包默认的GPS模块是m8u型号，在维特智能买的新GPS是m9u，需要在 ublox/ublox_gps/launch/ublox_gps.launch 中修改，

# 2021.09.22

## IMU测试

- 安装相关插件
```shell
sudo apt-get install ros-melodic-imu-tools ros-melodic-rviz-imu-plugin
```
- 创建文件夹，下载源码
```shell
mkdir -p  ~/handsfree/handsfree_ros_ws/src/
cd ~/handsfree/handsfree_ros_ws/src/
git clone https://gitee.com/HANDS-FREE/handsfree_ros_imu.git
cd ~/handsfree/handsfree_ros_ws/
catkin_make
cd ~/handsfree/handsfree_ros_ws/src/handsfree_ros_imu/scripts/
sudo chmod 777 *.py
echo "source ~/handsfree/handsfree_ros_ws/devel/setup.bash" >> ~/.bashrc
source ~/.bashrc
```
- 给串口赋权限
```shell
ls /dev/ttyUSB0
sudo chmod 777 /dev/ttyUSB0
```

- 功能包的使用

&emsp;陀螺仪和加速计发布的话题：/handsfree/imu

&emsp;磁力计发布的话题：/handsfree/mag

&emsp;1、通过 USB 连接线将 IMU 和电脑连接。

&emsp;2、运行 ROS 驱动可视化程序，打开 rviz 。
```shell
roslaunch handsfree_ros_imu rviz_and_imu.launch imu_type:=a9（改成你的imu的型号，可选项：a9，b9，b6）
```
&emsp;3、运行脚本获取 IMU 欧拉角格式数据：Roll（翻滚），Pitch（俯仰），Yaw（偏航）
```shell
rosrun handsfree_ros_imu get_imu_rpy.py
```

- launch文件描述

```
display_and_imu.launch

  打开 3d 的图形化界面节点和 IMU节点

handsfree_imu.launch

  打开 IMU 节点，默认打开型号为 a9 的IMU模块。

rviz_and_imu.launch

  打开 rviz 可视化界面和 IMU 节点

view_display.launch

  单独打开 3d 图形化界面，使用前需要先打开 IMU 节点。

view_rviz.launch

  单独打开 rviz 可视化界面，使用前需要先打开 IMU 节点。
```

# 2021.09.26

- 根据串口的 *KERNELS=="1-2.3"*关键字，映射串口名称

# 2021.10.20
 
- 更改脚本 newcontrol.py 为 control7.py

```python
#!/usr/bin/env python
#-*- coding:utf-8 –*-

#2021.10.27 更新,单独接收/gps/fix话题，单独发布路径信息

import math
from re import split
import json
import requests
import rospy

import tf
from tf.transformations import *
from sensor_msgs.msg import Imu

from sensor_msgs.msg import NavSatFix
from mygps.msg import myGPS
from std_msgs.msg import String
from std_msgs.msg import Float64

#pub = rospy.Publisher('deg_dis', myGPS, queue_size=10)  #发布话题设为全局变量
status = 0
the_location = []
yawdata = 0
net_state=True  # 网络状态
ttmcp = 0   #计次
msg = myGPS()
#获取指定地点的经纬度，输入为某个地名
def get_location_x_y(place):
    #place = input("请输入您要查询的地址")
    url = 'https://restapi.amap.com/v3/geocode/geo?parameters'
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'address':'%s' % place
    }
    page_resource = requests.get(url,params=parameters)
    text = page_resource.text       #获得数据是json格式
    data = json.loads(text)         #把数据变成字典格式

    location = data["geocodes"][0]['location']
    print(location)
    return location

#使用高德自带的坐标转换，将GPS坐标转换为gcj02坐标，返回 经度，纬度
def convert(lng, lat):
    rospy.loginfo("GPS坐标转换")
    url= 'https://restapi.amap.com/v3/assistant/coordinate/convert'
    location=str(lng)+','+str(lat)
    parameters = {
        'key':'2d3d0be8279d05e00314272bfa68734d',
        'locations':location,
        'coordsys':'gps'
    }
    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    # print(formatted_url)
    response = requests.get(formatted_url)
    text = response.text 
    data = json.loads(text)
    location = data['locations']

    return location

#路线规划，输入参数为起点和终点的经纬度，经纬度数据是gcj02坐标
def route_planning(lon1,lat1,lon2,lat2):
    rospy.loginfo("获取路线")
    from_location=str(lon1)+","+str(lat1)
    to_location=str(lon2)+","+str(lat2)

    #type = input("出行方式（1.公交、2.步行、3.驾车、4.骑行）,请输入数字")
    type = "2"
    url="https://restapi.amap.com"
    if type=="1":
        url = url+ "/v3/direction/transit/integrated"
    elif type=="2":
        url = url + "/v3/direction/walking"
    elif type=="3":
        url = url + "/v3/direction/driving"
    elif type == "4":
        url = url + "/v4/direction/bicycling"
    parameters = {
        'origin': from_location,
        'destination': to_location,
        'key': '2d3d0be8279d05e00314272bfa68734d',
        'extensions':'all',
        'output':'json',
    }

    formatted_url = url + '?' + '&'.join(["{}={}".format(k,v) for k,v in parameters.items()])  # ! # 坐标显示正常
    response = requests.get(formatted_url)
    print(formatted_url)
    txt = json.loads(response.text)

    global status 
    status = txt['status']

    status = int(status[0])
    #print("status",status)
    if status == 0:
        status = 0
        return 

        print("第1个return已结束")

    elif 'route' not in txt:
        print("error")
        status = 3
        return 

        print("第2个return已结束")
    else:
        txt = txt['route']['paths'][0]['steps']
        info=[]
        j=0
        for i in txt:
            i = i['polyline']
            info.append(j)
            j=j+1
            info.append(i)
        #print("第3个return之前已结束")
        status = 1
        return info

#获取点2相对于点1的绝对角度，正北方向为0°，输入参数为两个点的经纬度
def get_degree(lon1,lat1,lon2,lat2):
    rospy.loginfo("获取下一个点的角度-")

    rad=3.1415926535897932384626/180
    
    #角度转弧度
    lat1=lat1*rad
    lon1=lon1*rad
    
    lat2=lat2*rad
    lon2=lon2*rad
    
    a = math.sin(lon2-lon1) * math.cos(lat2)
    b = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon2-lon1)
    
    result = math.atan2(a,b)/rad
    if result<0 :
        result += 360 
    return result

#获取两点之间的距离，单位 m ,输入参数为两个点的经纬度
def get_distance(lon1,lat1,lon2,lat2):
    """
    算法来源：http://developer.baidu.com/map/jsdemo.htm#a6_1
    :param pointA: {lat:29.490295, lng:106.486654}
    :param pointB: {lat:29.615467, lng:106.581515}
    :return:米
    """
    rospy.loginfo("获取下一个点的距离+")

    R = 6370996.81 #球半径

    if (lon1 and lat1 and lon2 and lat2):
        if lat1 == lat2 and lon1 == lon2:
            distance = 0
        else:
            a_lat = lat1 * math.pi / 180
            a_lng = lon1 * math.pi / 180
            b_lng = lon2 * math.pi / 180
            b_lat = lat2 * math.pi / 180
            # print(a_lng,b_lng,a_lat,b_lat)
            distance = R * math.acos(math.sin(a_lat) * math.sin(b_lat) + math.cos(a_lat) * math.cos(b_lat) * math.cos(b_lng - a_lng))
        return distance

#返回第一个路径点的位置，包括 角度(°)和 距离(m)
def datapath(info, longitude, latitude): 
    rospy.loginfo("第一条路径数据")
    path=info[1].split(';') #获取第一条路径数据
    data=[]
    # 只使用第一个点
    lon=float(path[0].split(',')[0])
    lat=float(path[0].split(',')[1])
    
    degree = int(get_degree(lon,lat,longitude, latitude))
    distance = get_distance(lon,lat,longitude, latitude)

    data.append(str(degree)+","+str(distance))
    return data[0]

# 判断是否在国内   
def out_of_china(lng, lat):
    return not (lng > 73.66 and lng < 135.05 and lat > 3.86 and lat < 53.55)

# 判断是否连接互联网 |已弃用， 单独写成一个节点    
def isConnected():
    try:
        html = requests.get("http://www.baidu.com",timeout=2)
    except:
        return False
    return True

# 通过IMU获取偏航角
def callbackYaw(data):
    global yawdata
    error = 65  # 偏移量
    #这个函数是tf中的,可以将四元数转成欧拉角
    (r,p,y) = tf.transformations.euler_from_quaternion((data.orientation.x,data.orientation.y,data.orientation.z,data.orientation.w))
    #由于是弧度制，下面将其改成角度制看起来更方便
    #rospy.loginfo("Roll = %f, Pitch = %f, Yaw = %f",r*180/3.1415926,p*180/3.1415926,y*180/3.1415926)
    yawdata = (0-(y*180/3.1415926 + error ))%360
    rospy.loginfo("偏航角：%f", yawdata)

# 网络检测
def callbackNet(net):
    rospy.loginfo("网络状态：%s", net.data)
    status = net.data.split('-')[0]
    status = int(status)
    global net_state

    if status==200 :
        net_state=True
    if status==404 :
        net_state=False

# 获取GPS模块的数据
def callbackGPS(gps):
    # if out_of_china(gps.longitude, gps.latitude):
        # the_location = convert(106.606024,29.532828)      
    # else:
        # the_location = convert(gps.longitude,gps.latitude)    #转换为gcj02坐标
    global the_location
    #经度longitude  纬度latitude
    the_location = convert(gps.longitude,gps.latitude)    #转换为gcj02坐标

def DegDis():
    global ttmcp
    global net_state
    global the_location
    global msg
    global status
    global yawdata

    ttmcp = ttmcp + 1
    rospy.loginfo("%d", ttmcp)
    msg.compass=yawdata
    if net_state == True:   # 网络正常
        #使用 , 分割元素
        longitude=the_location.split(',')[0]
        latitude=the_location.split(',')[1]
        #rospy.loginfo('Listener: GPS: %s %s', (longitude), (latitude))

        rospy.loginfo("目标：南山派出所")
        goal_longitude=106.6023346
        goal_latitude=29.5357341

        info1 = route_planning(longitude,latitude,goal_longitude,goal_latitude)
        #print(info1)
        #print("status",status)
        

        if status != 1 :
            msg.state = status   # 0获取路径失败, 3没有具体的路径
            msg.deg = 0
            msg.dis = 0            
        elif status ==1 :   # 高德地图成功获取路径
            Deg_Dis = datapath(info1, float(longitude), float(latitude))
            msg.state = ttmcp+3
            msg.deg = int(Deg_Dis.split(',')[0])
            msg.dis = float(Deg_Dis.split(',')[1])
        if msg.deg==0:
            msg.compass = 0
        if msg.dis > 5:
            msg.dis = 5

    elif net_state == False:
       # global yawdata
        rospy.loginfo('The network is not connected')
        msg = myGPS()
        msg.state = 2   # 网络连接失败
        msg.deg = 0
        msg.dis = 0
            
# 监听
def listener():
    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称
    """
    sub_imu = rospy.Subscriber('/handsfree/imu', Imu, callbackYaw, queue_size=10)
    sub_net = rospy.Subscriber('/NetMonitor', String, callbackNet, queue_size=10)
    sub_gps = rospy.Subscriber('/gps/fix', NavSatFix, callbackGPS, queue_size=10)
    """
    rospy.Subscriber('/handsfree/imu', Imu, callbackYaw, queue_size=10)
    rospy.Subscriber('/NetMonitor', String, callbackNet, queue_size=10)
    rospy.Subscriber('/gps/fix', NavSatFix, callbackGPS, queue_size=10)   
    rospy.spin()

if __name__ == '__main__':
    rospy.init_node('pylistener', anonymous=True)
    pub = rospy.Publisher('deg_dis', myGPS, queue_size=10)  #发布话题设为全局变量
    rate = rospy.Rate(1)
    listener()
    global msg
    while not rospy.is_shutdown():         
        pub.publish(msg)
        rate.sleep()

```

- python读取维特智能的磁力计数据 (修改脚本 myserial.py 为 mag.py)

    话题名称：/magnetometer

    消息类型：/Float32

    磁力计信息：
    
    https://dl.wit-motion.com:2103/index.html#/wit-service/productLiterature/document?productId=bd69a7b1490a4af0a399636a248c8b7d

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
import rospy
import time
import serial #导入serial包
import datetime
from std_msgs.msg import String

def send(rev):
    Magx=rev.split(',')[0]
    Magy=rev.split(',')[1]
    Magz=rev.split(',')[2]
    Yaw =rev.split(',')[3]

    Magx=Magx.split(':')[1]
    Magy=Magy.split(':')[1]
    Magz=Magz.split(':')[1]
    Yaw =Yaw.split(':')[1] 

    Magx = int(Magx)*13
    Magy = int(Magy)*13
    Magz = int(Magz)*13
    rospy.loginfo("magx:%f magy:%f magz:%f yaw:%s", Magx*0.00001, Magy*0.00001, Magz*0.00001, Yaw)
    data = str(Magx)+":"+str(Magy)+":"+str(Magz)+":"+str(Yaw)
    
    return data

if __name__ == '__main__':
    rospy.init_node("Mag") #初始化ros节点
    ser = serial.Serial("/dev/mag", 9600, timeout=1) #打开串口, 端口号:"/dev/ttyUSB0". 波特率:9600. 延时等待1s
    if ser.isOpen(): #判断串口是否打开
        print("串口打开成功")
    else:
        print("串口打开失败")
        quit()
    pub = rospy.Publisher('magnetometer', String , queue_size=10)  #发布话题

    rate = rospy.Rate(10)   #频率10Hz

    while not rospy.is_shutdown():
        # print("1-------------------------------")
        print(datetime.datetime.now())
        ser.write('AT+PRATE=0\r\n')
        cnt = ser.inWaiting() #等待接受数据
        rev0 = ser.read(cnt) #读数
        rev=rev0.split()    #按换行分割数据

        if len(rev) == 2 :
            print rev[1]
            print("\033[32m数据符合\033[0m")
            if rev[0]=='OK' :
                data = send(rev[1])
                pub.publish(data)
                print("--over--")
            elif rev[1]=='OK':
                data = send(rev[0])
                pub.publish(data)
                print("--over--")

        rate.sleep()
```

# 2021.10.27

- 创建自动化脚本 gps.sh ，自动创建 gps_ws 空间

```shell
#! /bin/bash
echo "删除原来的包"
rm -rf gps_ws/

echo "创建工作空间并初始化"
cd ~
mkdir -p gps_ws/src
cd ~/gps_ws
catkin_make

echo "进入 src 创建 ros 包并添加依赖"
cd src
catkin_create_pkg mygps std_msgs rospy roscpp sensor_msgs

echo "安装python功能包"
sudo apt-get install python-requests

sleep 1s

echo "自定义发送的GPS消息类型"

cd ~/gps_ws/src/mygps
mkdir msg
cd msg

echo "创建自定义消息"

#touch myGPS.msg
#echo "uint16 state" >> myGPS.msg
#echo "uint32 deg" >> myGPS.msg
#echo "float64 dis" >> myGPS.msg
#echo "uint32 compass" >> myGPS.msg

cp ~/tmp/myGPS.msg .

# wget https://raw.githubusercontent.com/simoonp/little-project/main/src/gps/myGPS.msg
cat myGPS.msg

cd ~/gps_ws/src/mygps
echo "修改package.xml"
sed -ri '/<build_depend>std_msgs</ a\  <build_depend>message_generation</build_depend>' package.xml
sed -ri '/<build_export_depend>std_msgs</ a\ a\  <build_export_depend>message_generation</build_export_depend>' package.xml
sed -ri '/<build_export_depend>roscpp/ i\ ' package.xml	# 插入空行
sed -ri '/<exec_depend>std_msgs</ a\  <exec_depend>message_runtime</exec_depend>' package.xml
sed -ri '/<exec_depend>roscpp/ i\ ' package.xml	# 插入空行

echo "修改CMakeLists.txt"
sed -ri '/  rospy/ a\  message_generation' CMakeLists.txt

sed -ri '/# add_message_files/ i\ add_message_files(' CMakeLists.txt
sed -ri '/# add_message_files/ i\   FILES' CMakeLists.txt
sed -ri '/# add_message_files/ i\   myGPS.msg' CMakeLists.txt
sed -ri '/# add_message_files/ i\ )' CMakeLists.txt

sed -ri '/# generate_messages/ i\ generate_messages(' CMakeLists.txt
sed -ri '/# generate_messages/ i\   DEPENDENCIES' CMakeLists.txt
sed -ri '/# generate_messages/ i\   sensor_msgs   std_msgs' CMakeLists.txt
sed -ri '/# generate_messages/ i\ )' CMakeLists.txt

cd ~/gps_ws
catkin_make

echo "消息类型如下"
source ~/gps_ws/devel/setup.bash
rosmsg show myGPS

echo "添加py脚本"
cd ~/gps_ws/src/mygps
mkdir scripts
cd scripts
#wget https://raw.githubusercontent.com/simoonp/little-project/main/src/gps/control.py
#wget https://raw.githubusercontent.com/simoonp/little-project/main/src/gps/mag.py
wget https://raw.githubusercontent.com/simoonp/little-project/main/src/gps/net.py
cp ~/tmp/control.py .
cp ~/tmp/mag.py .
chmod u+x *.py

echo "添加底层控制程序"
cd ~/gps_ws/src/mygps
cd src
#wget https://raw.githubusercontent.com/simoonp/little-project/main/src/gps/ctrl.cpp
cp ~/tmp/ctrl.cpp .

echo "修改CMakeLists.txt"
cd ..
sed -ri '/# add_executable/ a\add_executable(ctrl src/ctrl.cpp)' CMakeLists.txt
sed -ri '/## Add cmake target dependencies of the executable/ a\add_dependencies(ctrl ${catkin_EXPORTED_TARGETS})' CMakeLists.txt
sed -ri '/# target_link_libraries/ i\target_link_libraries(ctrl ${catkin_LIBRARIES})' CMakeLists.txt

cd ~/gps_ws
echo "重新编译"
catkin_make -DCMAKE_EXPORT_COMPILE_COMMANDS=YES

sed -i '/gps_w/d' ~/.bashrc # 删除原来的source
echo "source ~/gps_ws/devel/setup.bash" >> ~/.bashrc

echo "下载并编译gps包"
cd ~/gps_ws/src
git clone https://github.com/ncnynl/ublox
cd ~/gps_ws/
catkin_make -DCMAKE_EXPORT_COMPILE_COMMANDS=YES

echo "修改gps端口"
cd ~/gps_ws/src/ublox/ublox_gps/config
sed -ri '/dev\/gps/ c\device: /dev/thegps' m8u_rover.yaml

echo "开启北斗"
sed -ri '/beidou/ c\  beidou: true' m8u_rover.yaml
```

# 2021.10.29

阅读 imu_filter_madgwick 包的相关代码，添加部分中文注释，得出加速度与磁力融合的数学公式，在不同坐标系下，矩阵的数值不一样

$$
\vec{H}=\vec{Mag} |times \vec{Acc}  \\
\vec{Acc}=Normalize(\vec{Acc})  \\
\vec{Mag}=\vec{Acc} \times \vec{H}  \\
NED:R=(Mag, H, -Acc)    \\
NWU:R=(Mag, -H, Acc)    \\
ENU:R=(H, Mag, Acc)
$$

修改该包在bringup_new.launch文件中的相关参数，开启两个mag标志位，将 world_frame 设置为 nwu(西北天坐标系)，保持和Hfi-a9陀螺仪的方向一致

重新下载 handsfree_ros_imu 包的代码（代码有更新, 下载new分支的代码）
```shell
git clone -b new https://gitee.com/HANDS-FREE/handsfree_ros_imu.git
```

将 hfi_a9_ros.py 脚本中，imu和mag的话题分别修改为 /imu/data_raw 和 imu/mag，方便和 imu_filter_madgwick 对接

修改后重新运行launch文件，数据精度有一些提高，待导航验证

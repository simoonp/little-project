# 学习内容

|学习内容|链接|
|:--:|----|
|算法零基础|https://blog.csdn.net/whereisherofrom/category_11426012.html?spm=1001.2014.3001.5482|
|画数据结构|https://blog.csdn.net/whereisherofrom/category_11227297.html?spm=1001.2014.3001.5482|
|C语言100例|https://blog.csdn.net/whereisherofrom/category_11158834.html?spm=1001.2014.3001.5482|
|夜深人静写算法|https://blog.csdn.net/whereisherofrom/category_9273531.html?spm=1001.2014.3001.5482|
|LeetCode算法全集|https://blog.csdn.net/whereisherofrom/category_11178770.html|
|力扣周赛题解|https://blog.csdn.net/whereisherofrom/category_11669028.html|
|LeetCode零基础指南|https://blog.csdn.net/whereisherofrom/category_11492771.html?spm=1001.2014.3001.5482|
|FPGA||
|嵌入式||
|六级||

# 4.01

## 1、算法基础快速回顾

#### 1.1.1、幂

「 幂 」 是指数运算的结果。$n^m$ 看作乘方的结果，叫做 n 的 m 次幂，也叫n 的 m 次方。

当 m 为正整数时，$n^m$ 代表 m 个 n 相乘； 当 m 为小数时，m 可以写成$\frac a b $  (其中 a 、b 为整数），$n^m$ 可以表示成：
$$
n^m=n^{\frac{a}{b}}=\sqrt[b]{n^a}
$$
在C语言中，可以利用函数`pow(n,m)`来计算$n^m$。

#### 1.1.2、对数

**「 对数 」** 是对 幂 的逆运算。当 n 的 m 次方等于 T(n > 0 ，且 n ≠ 1 ) ，即$T=n^m$，那么m叫做`以n为底，T的对数`，记作$m=\log _{n} T$，其中， n 叫做对数的`底数`，T 叫做`真数`。

在C语言中，可以利用`log2(T)`来计算以2为底，T的对数；`log10(T)`表示：以10为底，T的对数。

#### 1.1.3、换底公式

$$
\log _{a}{b}=\frac{\log _{c} b}{\log _{c} a}
$$

##### [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)


**思路：**

若n是2的幂，则n的二进制表示金最高位是1，其余都是0，而n-1的二进制表示全为1，因此$n \& (n-1) == 0$，并且需要保证$n>0$。

- 时间复杂度：$O(1)$。
- 空间复杂度：$O(1)$。

```c
bool isPowerOfTwo(int n){
    return (n>0) && ((n&(n-1))==0);
}
```

##### [326. 3 的幂](https://leetcode-cn.com/problems/power-of-three/)


**思路1**

不断地将 n 除以 3 ，直到 n=1 。如果此过程中 n 无法被 3 整除，就说明 n 不是 3 的幂。

时间复杂度：$O(\log n)$，当 n 是 3 的幂时，需要除以 3 的次数为 $\log_3 n = O(\log n)$；当 n 不是 3 的幂时，需要除以 3 的次数小于该值。

空间复杂度：$O(1)$。

```c
bool isPowerOfThree(int n){
    while(n && n%3==0)
        n /= 3;
    return n==1;
}
```

**思路2**

3232 位有符号整数的范围内，最大的 33 的幂为 $3^{19} = 11622614673$。我们只需要判断 n 是否是$3^{19}$ 的约数即可。这里需要判断 n 是否为正数。

- 时间复杂度：$O(1)$。
- 空间复杂度：$O(1)$。

```c
bool isPowerOfThree(int n){
    return (n > 0) && (1162261467 % n == 0);
}
```

##### [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

**思路1**

如果 n 是4的幂，那么n的二进制表示最高位为1，且后面有偶数个0，构造一个数mask，它的二进制表示中，所有偶数位都是1，奇数位为0，即`1010···1010`的形式，由于n是32位有符号整数，所以mask表示为`1010 1010 1010 1010 1010 1010 1010 1010`，用十六进制表示为`0x AAAA AAAA`。需要判断n是否为正数。

- 时间复杂度：$O(1)$。
- 空间复杂度：$O(1)$。

```c
bool isPowerOfFour(int n) {
    return n > 0 && (n & (n - 1)) == 0 && ((n&0xaaaaaaaa)==0);
}
```

**思路2**

如果 n 是4的幂，那么n一定是2的幂，并且可以表示为$4^k$，那么
$$
4^k=(3+1)^k=\sum_{k=0}^{n}
\left(\begin{array}{l}
n \\
k
\end{array}\right) 3^{k}	\\
其中，
\left(\begin{array}{l}
n \\
k
\end{array}\right)=\frac{n!}{k!(n-k)!}
$$
所以，n%3=1。

若n是2的幂，且不是4的幂，那么n可以表示为$2*4^x$，n%3=2。

因此，可以在判断n是2的幂的基础上，通过判断n除以3的余数是否为1来判断n是否为3的幂。

- 时间复杂度：$O(1)$。
- 空间复杂度：$O(1)$。

```c
bool isPowerOfFour(int n) {
    return n > 0 && ((n & (n - 1)) == 0) && (n % 3 == 1);
}
```

#### 1.2.1、斐波那契数列

对于斐波那契数列而言，除了第 0 项 和 第一项以外，任何一个项等于前两项之和，递推公式如下：
$$
f(n)= \begin{cases}0 & n=0 \\ 1 & n=1 \\ f(n-1)+f(n-2) & n>1\end{cases}
$$

##### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

**思路1**

根据斐波那契数列的定义，使用迭代的方法，从0累加到n。

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

```c
int fib(int n){
    if(n){
        int p = 0, q = 0, r = 1;
        for (int i = 2; i <= n; ++i) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
    return 0;
}
```

**思路2**

使用矩阵快速幂的方法可以降低时间复杂度。

构建递推关系
$$
\begin{gathered}
{\left[\begin{array}{ll}
1 & 1 \\
1 & 0
\end{array}\right]\left[\begin{array}{c}
F(n) \\
F(n-1)
\end{array}\right]=\left[\begin{array}{c}
F(n)+F(n-1) \\
F(n)
\end{array}\right]=\left[\begin{array}{c}
F(n+1) \\
F(n)
\end{array}\right]} \\
因此
{\left[\begin{array}{c}
F(n+1) \\
F(n)
\end{array}\right]=\left[\begin{array}{ll}
1 & 1 \\
1 & 0
\end{array}\right]^{n}\left[\begin{array}{l}
F(1) \\
F(0)
\end{array}\right]} \\
构建：M=\left[\begin{array}{ll}
1 & 1 \\
1 & 0
\end{array}\right]
\end{gathered}
$$
只要能快速计算矩阵 M 的 n 次幂，就可以得到 F(n) 的值，定义矩阵乘法，然后用快速幂算法来加速这里 $M^n$ 的求取。

时间复杂度：$O(\log n)$，当 n-1 是 2 的幂时，需要除以 2 的次数为 $\log_2 (n-1) = O(\log n)$；当 n-1 不是 2 的幂时，需要除以 2 的次数小于该值。

空间复杂度：$O(1)$。

```c
// 构建矩阵结构体
struct Matrix {
    int mat[2][2];
};
// 定义矩阵乘法
struct Matrix matrixMultiply(struct Matrix* a, struct Matrix* b) {
    struct Matrix c;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            c.mat[i][j] = (*a).mat[i][0] * (*b).mat[0][j] + (*a).mat[i][1] * (*b).mat[1][j];
        }
    }
    return c;
}
// 定义矩阵的幂
struct Matrix matrixPow(struct Matrix a, int n) {
    struct Matrix ret;
    ret.mat[0][0] = ret.mat[1][1] = 1;
    ret.mat[0][1] = ret.mat[1][0] = 0;
    while (n > 0) {
        if (n & 1) {
            ret = matrixMultiply(&ret, &a);
        }
        n >>= 1;
        a = matrixMultiply(&a, &a);
    }
    return ret;
}

int fib(int n) {
    if (n < 2) {
        return n;
    }
    struct Matrix q;
    q.mat[0][0] = q.mat[0][1] = q.mat[1][0] = 1;
    q.mat[1][1] = 0;
    struct Matrix res = matrixPow(q, n - 1);
    return res.mat[0][0];
}
```

**思路3**

![image-20220401152809956](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/04/upgit_20220401_1648798090.png)

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

```c
int fib(int n) {
    double sqrt5 = sqrt(5);
    double fibN = pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n);
    return round(fibN / sqrt5);
}
```

##### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

**思路**

利用逻辑运算符的短路性质，对于`A && B`，若`A`是False，则确定`A && B`也是False，不会再执行`B`，将`A`作为递归的出口，`B`作为递归的主体函数，如果不是出口，则会执行`B`，否则递归结束。

```c
int sumNums(int n){
    n && (n += sumNums(n-1));
    return n;
}
```

##### [896. 单调数列](https://leetcode-cn.com/problems/monotonic-array/)

**思路**

设置两个标志，一个代表数列单调增，一个代表数列单调减，当两个标志同时为1时，表示数列不单调。

```c
bool isMonotonic(int* nums, int numsSize){
    int flag1=0, flag2=0;
    for(int i=1; i<numsSize; i++){
        if(nums[i] > nums[i-1])
            flag1=1;
        if(nums[i] < nums[i-1])
            flag2=1;
        if(flag2==1 && flag1==1)
            return false;
    }
    return true;
}
```

- 时间复杂度：$O(n)$。
- 空间复杂度：$O(1)$。

##### [1313. 解压缩编码列表](https://leetcode-cn.com/problems/decompress-run-length-encoded-list/)

**思路**

根据题目数据的要求，创建一个指针数组，再向数组里填值。

- 时间复杂度：外层循环$\frac n 2$次，内存最多循环100次，复杂度为$O(50n)$
- 空间复杂度：$O(1)$。

```c
int* decompressRLElist(int* nums, int numsSize, int* returnSize){
    int * ret=(int *)malloc(sizeof(int)*50*numsSize);
    int all=0;
    for(int i=0; i<numsSize; i=i+2){
        for(int j=0; j<nums[i]; j++)
            ret[all++]=nums[i+1];
    }
    *returnSize = all;
    return ret;
}
```

##### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

**思路1**

若S是连续一串数的和，假设这串数的起点是i，终点是j，则根据等差数列求和有$\frac{(i+j)(j-i+1)}{2}=S$，由于j>0，$j=\frac{-1+\sqrt{1+4(2S+i^2-i)}}{2}$，为确保j是偶数，需要满足$\sqrt{1+4(2S+i^2-i)}$为奇数。

```c
int** findContinuousSequence(int target, int* returnSize, int** returnColumnSizes){
    int r=target, c=target;
    int ** ret =(int **)malloc(sizeof(int *)*r);
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int tmp_sum=0;

    int i = 1, num=0, limit=(target-1)/2, target_8=8*target+1;
    double j = 2.0;
    while(i <= limit) {
        long long delta =target_8 + 4 * ( (long long) i * i - i);
        int delta_sqrt = (int)sqrt(delta);
        if(1ll*delta_sqrt*delta_sqrt==delta && delta_sqrt%2==1){
            j=(delta_sqrt-1)/2;
            int len=j-i+1;
            ret[num]=(int *)malloc(sizeof(int)*(len));
            (*returnColumnSizes)[num]=len;
            for(int k = i; k <= j; k++){
                ret[num][k-i]=k;
            }
            num++;
        }
        i++;
    }
    *returnSize=num;
    return ret;
}
```

**思路2**

双指针

用两个指针$l$和$r$表示枚举区间的起点和终点，$sum$表示$[l,r]$的区间和，$sum=\frac{(l+r)(r-l+1)}{2}$，起始$l=1,r=2$。

当$sum<S$时，说明右指针$r$还可以向右移动，来使$sum$增大，此时$r++$；

当$sum>S$时，说明区间内的数太多，应该使左指针$l$向右移动，来使$sum$减小，此时$l++$；

当$sum==S$时，说明找到了合适的一串连续数字，将$[l,r]$序列存放到答案中，因为以$l$为起点的数字序列只有一个，此时需要将$l$向右移动一位；当$l$移动后若$r$不移动，则$sum$会变小，所以$r$也需要向右移动一位；但若$l$和$r$都向右移动1为，则$sum$会增大2，为了控制$sum$需要将$l$再向右移动1位，来限制$sum$的第一次增大；因此，合适的方案时$l+=2,r++$。

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

int** findContinuousSequence(int target, int* returnSize, int** returnColumnSizes){
    int ** ret =(int **)malloc(sizeof(int *)*target);
    *returnColumnSizes=(int *)malloc(sizeof(int)*target);
    int num=0;
     for (int l = 1, r = 2; l < r;){
        int sum = (l + r) * (r - l + 1) / 2;
        if (sum == target) {
            int len=r-l+1;
            ret[num]=(int *)malloc(sizeof(int)*(len));
            (*returnColumnSizes)[num]=len;
            for(int k = l; k <= r; k++){
                ret[num][k-l]=k;
            }
            l+=2;
            r++;
            num++;
        } else if (sum < target) {
            r++;
        } else {
            l++;
        }
    }
    *returnSize=num;
    return ret;
}
```

##### [829. 连续整数求和](https://leetcode-cn.com/problems/consecutive-numbers-sum/)

若使用和上面一样的思路，当测试数据过多时会有超时的问题

**思路1**

设区间序列的第一个数位$a$，区间长度位$k$，那么$sum=\frac{(a+a+k-1)k}{2}$，$ak=S-\frac{k^k-k}{2}$，$(S-\frac{k^k-k}{2})\%k==0$，同时可以算得$k=\frac{\sqrt{(8S+(2a-1)^2)}-(2a-1)}{2}$，根据单调性分析，$a$越小$k$越大，那么$k \leq \sqrt{2S}$。

```c
int consecutiveNumbersSum(int N){
    int end=sqrt(2*N), ans=0;
    for(int k=1; k<=end; k++)   
        ans += ((N-(k*k-k)/2)%k==0);
    return ans;
}
```

# 4.02

### 1.3、矩阵

##### [1672. 最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)

**思路**

遍历二维数组得第一维，求和比较最大值

```c
int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){
    int r=accountsSize;
    int max=0;
    for(int i=0; i<r; i++){
        int all=0;
        for(int j=0; j<accountsColSize[i]; j++)
            all += accounts[i][j];
        if(max < all)
            max=all;
    }
    return max;
}
```

##### [1582. 二进制矩阵中的特殊位置](https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/)

**思路**

二维数组为r行c列，在特殊位置的那个值，整行、整列的值都是1；

先定义一个长度位r的数组`rdata[r]`用来记录第`i`行是否只有一个1，若只有一个1(假设这个1是在第j列)，将`j+Flag`存入`rdata[i]`中，否则`rdata[i]=0`，当检测到出现两个1时，直接跳出本次循环；第`i`行遍历结束后，若`rdata[i]>0`表示该行只有一个1，然后根据里面存放的值去遍历`j`列，累加第`j`列所有值，若累计和为1，则表示该列只有一个1，符合特殊位置的条件，否则说明该列有多个1，不符合。

```c
int numSpecial(int** mat, int matSize, int* matColSize){
    int r=matSize, c=matColSize[0], ans=0;
    
    int rdata[r], cdata[c];
    for(int i=0; i<r; i++){
        rdata[i]=0;
        for(int j=0; j<c; j++)
            if(mat[i][j]==1)
                if(rdata[i]==0)
                    rdata[i]=j+5;
                else{
                    rdata[i]=0;
                    break;
                }

        if(rdata[i]){
            int sum=0;
            for(int j=0; j<r; j++)
                sum += mat[j][rdata[i]-5];
            if(sum == 1)
                ans++;
        }
    }
    return ans;        
}
```

##### [832. 翻转图像](https://leetcode-cn.com/problems/flipping-an-image/)

**思路**

创建一个二维指针，按照输入分配内存，将值依次赋值`ret[i][j]=1-image[i][c-1-j]`

```c
int ** myMalloc(int r, int c, int* returnSize, int** returnColumnSizes){
    int i;
    int ** ret = (int **)malloc(sizeof(int *) * r);
    *returnColumnSizes = (int *)malloc(sizeof(int) *r);
    *returnSize = r;
     for(i=0; i<r; i++){
         ret[i]=(int *)malloc(sizeof(int) * c);
         (*returnColumnSizes)[i] = c;
     }
     return ret;
}

int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){
    int i,j;
    int r=imageSize, c=imageColSize[0];
    int ** ret=myMalloc(r, c, returnSize, returnColumnSizes);
    for(i=0; i<r; i++)
        for(j=0; j<c; j++)
            ret[i][j]=1-image[i][c-1-j];
    return ret;
}
```

##### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

**思路1**

想象二维矩阵每个元素的位置对应二维坐标系上的点，将所有点向第三坐标系的方向移动$(\frac n 2,\frac n 2)$，然后使用旋转矩阵，顺时针旋转90°，旋转完了以后向第一象限移动$(\frac n 2,\frac n 2)$。

$(i,j) \rightarrow (i-\frac n 2 ,j-\frac n 2) \rightarrow (\frac n 2 - j, i-\frac n 2 ) \rightarrow (n - j, i)$

*注：这里顺时针旋转90°，在数学上时逆时针旋转90°，方向好像反过来的。*

```c
int ** myMalloc(int r, int c){
    int i;
    int ** ret=(int **)malloc(sizeof(int *)*r);

    for(i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int) * c);
    }
    return ret;
}

void rotate(int** matrix, int matrixSize, int* matrixColSize){
    int n= matrixSize;
    int ** ret=myMalloc(n,n);

    for(int i=0; i<n; i++)
        for(int j=0; j<n; j++)
            ret[i][j]=matrix[n-1-j][i];
            // ret[i][j]=matrix[n-1-j][n-1-i];

    for(int i=0; i<n; i++)
        for(int j=0; j<n; j++)
            matrix[i][j]=ret[i][j];
}
```

##### [867. 转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)

**思路**

新建一个二级指针`ret`，`ret[i][j]=matrix[j][i]`

```c
int ** myMalloc(int r, int c, int *returnSize, int ** returnColumnSizes){
    int i;
    int ** ret=(int **)malloc(sizeof(int *)*r);
    *returnColumnSizes = (int *)malloc(sizeof(int)*r);
    *returnSize=r;
    for(i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int) * c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}

int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
    int r=matrixSize, c=matrixColSize[0];
    int **ret=myMalloc(c, r, returnSize, returnColumnSizes);
    for(int i=0; i<c; i++)
        for(int j=0; j<r; j++){
            ret[i][j]=matrix[j][i];
        }
    return ret;
}
```

##### [2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

```c
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;    
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int **ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int)*c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){
    int ** ret;
    if(n*m != originalSize){
        *returnSize=0;
        return ret;
    }
    ret=myMalloc(m, n, returnSize, returnColumnSizes);
    for(int i=0; i<m; i++)
        for(int j=0; j<n; j++)
            ret[i][j]=original[i*n+j];
    return ret;
}
```

##### [1886. 判断矩阵经轮转后是否一致](https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)

**思路**

将`mat`依次与`target`旋转0°、90°、180°、270°的情况比较。

```c
bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize){
    
    int n=matSize, flag=0;
    for(int i=0; i<n; i++)
        for(int j=0; j<n; j++)
            if(target[i][j] != mat[i][j]){
                flag=1;
                break;
            }  
    // 顺时针90
    if(flag==1)
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(target[i][j] != mat[n-1-j][i]){
                    flag=2;
                    break;
                }         
        // 180
    if(flag==2)
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(target[i][j] != mat[n-1-i][n-1-j]){
                    flag=3;
                    break;
                }
    // // 逆时针90
    if(flag==3)
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(target[i][j] != mat[j][n-1-i]){
                    flag = 4;
                    break;
                }
    if(flag == 4 )
        return false;       
         
    return true;
}
```

##### [1260. 二维网格迁移](https://leetcode-cn.com/problems/shift-2d-grid/)

**思路**

想象二维网格压平成一维，`(i,j)`在一维网格的位置时`id=i*c+j`，网格迁移`k`次，新网格的`(i,j)`是一维网格的第`id=id-k`个数，然后将一维网格重新还原为二维，即`new(i,j)=old(id/c,id%c)`，c是原二维网格的行数。

```c
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=gridSize, c=gridColSize[0], id;
    int **ret = myMalloc(r, c, returnSize, returnColumnSizes);
    k=k%(r*c);
    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id= i*c+j-k;
            if(id<0)
                id += (r*c);
            ret[i][j]=grid[id/c][id%c];
        }
    return ret;
}
```

##### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)



```c
int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    if (matrixSize == 0 || matrixColSize[0] == 0) {
        *returnSize = 0;
        return NULL;
    }

    int rows = matrixSize, columns = matrixColSize[0];
    int visited[rows][columns];
    memset(visited, 0, sizeof(visited));
    int total = rows * columns;
    int* order = malloc(sizeof(int) * total);
    *returnSize = total;

    int row = 0, column = 0;
    int directionIndex = 0;
    for (int i = 0; i < total; i++) {
        order[i] = matrix[row][column];
        visited[row][column] = true;
        int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
        if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
            directionIndex = (directionIndex + 1) % 4;
        }
        row += directions[directionIndex][0];
        column += directions[directionIndex][1];
    }
    return order;
}
```

# 4.03

### 1.4、组合数

组合数$C_{n}^{m}$表示从`n`个不一样的元素中，选取`m`个元素的方案数

组合数的递推公式为
$$
C_{n}^{m}=C_{n-1}^{m-1}+C_{n-1}^{m}
$$
对于特殊情况$C_0^0 = 1$

##### [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

```c
int** generate(int numRows, int* returnSize, int** returnColumnSizes){
    int ** ret=(int **)malloc(sizeof(int *)*numRows);
    *returnSize = numRows;
    *returnColumnSizes=(int *)malloc(sizeof(int)*numRows);
    for(int i=0; i<numRows; i++){
        ret[i]=(int *)malloc(sizeof(int)*(i+1));
        (*returnColumnSizes)[i]=i+1;
        ret[i][0]=ret[i][i]=1;
        for(int j=1; j<i; j++){
            ret[i][j] = ret[i-1][j] + ret[i-1][j-1]; 
        }
    }
    return ret;
}
```

##### [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

```c
int* getRow(int rowIndex, int* returnSize){
    int numRows=rowIndex+1;
    int ** ret=(int **)malloc(sizeof(int *)*numRows);
    *returnSize = numRows;
    int i=0;
    for(i=0; i<numRows; i++){
        ret[i]=(int *)malloc(sizeof(int)*(i+1));        
        ret[i][0]=ret[i][i]=1;
        for(int j=1; j<i; j++){
            ret[i][j] = ret[i-1][j] + ret[i-1][j-1]; 
        }
    }
    return ret[i-1];
}
```

## 2、Linux嵌入式

#### 2..1.1、Linux环境变量

若希望所有用户，所有进程都能访问到某个变量，需要将这个变量添加到`/etc/bash.bashrc`中；

若只希望某个用户的所有进程可以访问某个变量，则将这个变量添加到`~/.bashrc`中；

#### 2.1.2、执行shell脚本的两种方式

1、在当前进程中运行：

```shell
# 脚本已被赋予执行权限
source 脚本名

. 脚本名
```

2、在子shell中执行

```shell
./bin/bash 脚本名
./脚本名
```

#### 2.1.3、deb软件包

| 文件类型 | 保存目录 |
| -------- | -------- |
| 普通程序 |/usr/bin|
|root权限程序|/usr/sbin|
|程序配置文件|/etc|
|日志文件|/var/log|
|文档文件|/usr/share/doc|

**deb软件包**：Debian，Ubuntu，Deepin等Linux发行版的软件安装包。

**dpkg工具**：底层的包管理工具，主要用于对已下载到本地和已经安装的deb包进行管理。

```shell
# 相关命令
# 安装软件
dpkg -i xxx.deb
# 查看安装目录
dpkg -L xxx
# 显示软件版本
dpkg -l xxx
# 查看软件详细信息
dpkg -s xxx
# 罗列内容
dpkg -c xxx.deb
# 卸载软件包
dpkg -r xxx

```

**deb包文件结构**

- DENIAN目录
    - control文件(必要)
        - Package：软件名称
        - Version：版本
        - Section：软件类别
        - Priority：对系统的重要性
        - Architecture：支持的硬件平台
        - Maintainer：软件包的维护者
        - Description：对软件的描述

    - preinst文件：安装之前执行的shell脚本 (可选)
    - postinst文件：安装之后执行的shell脚本
    - prerm文件：卸载之前执行的shell本
    - postrm文件：卸载之后执行的shell脚本
    - copyright文件：版权声明
    - changlog文件：修改记录

- 软件具体安装目录

    ​			视实际需求

#### 2.2.1、烧录镜像

打开`balena Etcher`；

选择镜像`imx6ull-lubancat-carp-qt-armhf-2022-02-10.img.xz`；

选择内存卡

开始烧录

#### 2.2.2、连接开发板

![image-20220403221626869](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/04/upgit_20220403_1648995387.png)

选择SD卡启动方式

![image-20220403221802506](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/04/upgit_20220403_1648995482.png)

提前安装好`CH340`驱动

使用`MobaXterm`通过串口连接开发版

![image-20220403222305693](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/04/upgit_20220403_1648995785.png)

**P**：若遇到由于上次使用`poweroff`关机，导致的无法开机的问题，可以尝试扣掉板子上的纽扣电池，重新装上纽扣电池，再开机

```shell
用户名：debian
密码：temppwd

用户名：root
密码：root
```

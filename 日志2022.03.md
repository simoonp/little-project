# 2022.03.01

## 上传GitHub，git push失败

失败提示： `gnutls_handshake() failed: The TLS connection was non-properly terminated.`

1、重置代理
```shell
git config --global  --unset https.https://github.com.proxy 
git config --global  --unset http.https://github.com.proxy 
```

2、重新设置账户
```shell
git config --global user.name "xxx"
git config --global user.email "xxxx"
```

3、重新申请token

4、git push时输入新的token

## U盘被分区后，重新格式化成一个盘

1、Win + R，输入CMD，打开Windows终端

2、输入 `diskpart` 指令，弹出新窗口

3、输入 `list disk` 列出所有磁盘

4、输入 `select disk 磁盘序号` 选择磁盘

5、输入 `clean` 清除分区，然后就可以在磁盘管理器里面看到一块未格式化的磁盘

![Image](https://raw.githubusercontent.com/simoonp/picture/main/log/disk.png)


## git删除远程文件
```shell
git rm --cached 文件名
```

## 微星主板刷BIOS

1、在微星官网下载BIOS文件，将压缩包内的 `.2E0` 文件重命名为 `MSI.ROM` 复制到FAT32格式U盘的根目录下

(注：部分劣质U盘，主板可能无法识别)

2、将主板插上24Pin主板供电和8Pin供电，电源上电，主机开关不用开启

3、将U盘插到主板带有BIOS或Flash字样的USB口（没有标注的查阅说明书或询问客服），长按BIOS刷写按钮3秒然后松开，当红灯开始闪烁说明正在搜索BIOS文件，红灯快速闪烁说明正在写入BIOS，指示灯熄灭表示写入完毕(也可能写入完毕后指示灯常亮)。

## 京东脚本库
```shell
1、
ql repo https://github.com/zero205/JD_tencent_scf.git "jd_|jx_|jdCookie" "backUp|icon" "^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql" "main"
2、
ql repo https://github.com/atyvcn/jd_scripts.git "jd_|jx_|ty_|CheckRpeat" "activity|backUp|icon" "^jd[^_]|^JD|USER|utils|function|^sign|sendNotify"
3、
ql repo https://github.com/smiek2221/scripts.git "jd_|gua_" "" "ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js"

4、
ql repo https://github.com/he1pu/JDHelp.git "jd_|jx_|getJDCookie" "activity|backUp|jd_delCoupon" "^jd[^_]|USER"
```

## leetcode刷题——01——函数

### 1、[两整数求和](https://leetcode-cn.com/problems/sum-of-two-integers/)，[面试题 17.01. 不用加号的加法](https://leetcode-cn.com/problems/add-without-plus-lcci/)，[剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```C
int add(int a, int b){
    if(b == 0)
        return a;
    return add(a^b,(a&(b&0xffffffff))<<1);
    // 为啥b加上0xffffffff后就不报错了？
    // LC C/C++不支持负值左移，需要强制转换为无符号数
    // return add(a^b,(unsigned int)(a&(b))<<1);
}
```
### 2、[递归乘法](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

```C
int multiply(int A, int B){
    //return A*B;

    // if(B==0)
    //     return 0;
    // int temp_a=A;
    // if(B>0){
    //     while(B>1){
    //         A += temp_a;
    //         B--;
    //     }
    // }else if(B<0){
    //     while(B<-1){
    //         A += temp_a;
    //         B++;
    //     }
    // }
    // return A;
       
    if (B==0)
        return 0;
    if (B>1)
        return A + multiply(A, B-1);
    else if(B<-1)
        return A + multiply(A, B+1);
    return A;

}
```

### 3、[Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

```C
double myPow(double x, int n){
    double res = 1;
    int i = n;
    while(i){
        if(i%2)
            res *= x;
 
        x *= x;

        i /= 2;
    }

    // double res = 1.0;
    // for(int i = n; i != 0; i /= 2){
    //     if(i % 2 != 0){
    //         res *= x;
    //     }
    //     x *= x;
    // }

    return  n < 0 ? 1 / res : res;

}
```

### 4、[x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

```C
int mySqrt(int x){
    // return sqrt(x);

    // int i=1, tmp = 1;
    // while(tmp<46340 && i<x){
    //     tmp++;
    //     i = tmp*tmp;
    // }
    // if(i > x)
    //     tmp--;
    // return tmp;

    // 牛顿迭代法
    if(x == 1)
        return 1;
    int min = 0;
    int max = x;
    while(max-min>1)
    {
        int m = (max+min)/2;
        if(x/m<m)
            max = m;
        else
            min = m;
    }
    return min;
}
```

### 5、[面试题 16.07. 最大数值](https://leetcode-cn.com/problems/maximum-lcci/)

```C
int maximum(int a, int b){
// a < b:
// 1 + (a - b) >> 31 == 0
// a > b:
// 1 + (a - b) >> 31 == 1

    long c = a, d = b;
    int k = 1 + ((c - d) >> 63);
    return k * a + (!k) * b;
}
```

### 6、[2119. 反转两次的数字](https://leetcode-cn.com/problems/a-number-after-a-double-reversal/)

```C
bool isSameAfterReversals(int num){
    if(num==0 || num%10)
        return true;
    return false;
}
```



# 2022.03.03

## 刷机 Redmi AC2100

### 需要的固件

`ac2100 breed` breed-mt7621-xiaomi-r3g.bin

`AC2100 2.0.7 旧固件` miwifi_rm2100_firmware_d6234_2.0.7.bin

`OpenWRT临时固件` openwrt-21.02.2-ramips-mt7621-xiaomi_redmi-router-ac2100-initramfs-kernel.bin

`Openwrt系统固件` openwrt-ramips-mt7621-xiaomi_redmi-router-ac2100-squashfs-sysupgrade.bin

scp -r breed-mt7621-xiaomi-r3g.bin root@192.168.31.1:/tmp/

### 1、系统降级

完成路由器的基本设置(设置密码)，登录路由器管理界面，在页面右上角，系统升级的位置，选择手动升级，选择下载的`miwifi_rm2100_firmware_d6234_2.0.7.bin`旧系统固件，完成后等待系统自动重启

![Snipaste_2022-03-03_17-10-30](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-10-30.png)

### 2、开启SSH

重新完成路由器基本设置，登录路由器后台，看浏览器地址连的url地址，记录stok后面的一串字符

```C
// ip可能会不一样，<stok>是一长串字符每次登录后都不一样
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/web/home#router
```

![Snipaste_2022-03-03_14-37-53](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-37-53.png)

使用下述代码进行注入，将`<stok>`替换为浏览器地址栏显示的值后再输入进地址栏

```c
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B
```

![Snipaste_2022-03-03_14-39-10](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-39-10.png)

输入地址，回车后，浏览器会显示`{"code":0}`

![Snipaste_2022-03-03_14-42-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-42-15.png)

退出再刷新浏览器重新进入管理界面，此时`<stok>`会发生变化，再通过下述代码修改root密码：

![Snipaste_2022-03-03_14-43-09](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-43-09.png)

```C
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B
```

![Snipaste_2022-03-03_14-44-49](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-44-49.png)

此时能够使用ssh登录进路由器，账号为：root 密码为：admin

使用CMD控制台ssh进入路由器系统(路由器IP：192.168.31.1)

![Snipaste_2022-03-03_14-46-09](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-46-09.png)

### 3、刷入breed

新开一个CMD窗口，通过scp指令远程上传文件到路由器`/tmp/`文件夹

![Snipaste_2022-03-03_14-54-27](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-54-27.png)

备份路由器原来的分区文件

![Snipaste_2022-03-03_15-20-03](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-20-03.png)

```shell
# 在路由器终端输入
dd if=/dev/mtd0 of=/tmp/all.bin
dd if=/dev/mtd1 of=/tmp/bootloader.bin
dd if=/dev/mtd4 of=/tmp/eeprom.bin
```

将备份的文件下载到本地

```shell
# 在Windows的CMD控制台输入：
scp root@192.168.31.1:/tmp/all.bin .
scp root@192.168.31.1:/tmp/bootloader.bin .
scp root@192.168.31.1:/tmp/eeprom.bin .
```

![Snipaste_2022-03-03_17-19-48](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-19-48.png)

![Snipaste_2022-03-03_15-21-32](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-21-32.png)

在路由器终端执行：

```she
mtd -r write /tmp/breed-mt7621-xiaomi-r3g.bin Bootloader
```

![Snipaste_2022-03-03_15-23-03](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-23-03.png)

### 4、刷入临时系统

如果电脑重新获取到IP后说明刷写完成并且breed引导了官方固件，断电。按住reset键（背面圆孔，用取卡针插进去）后插电等待system的蓝灯闪烁后松开reset键。

用浏览器访问`192.168.1.1`进入breed恢复界面，更改环境变量，新增字段"xiaomi.r3g.bootfw", 值设置为 2,然后保存。

![Snipaste_2022-03-03_15-26-44](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-26-44.png)

![Snipaste_2022-03-03_15-28-53](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-28-53.png)



点击固件更新，上传自己的固件(选择 `openwrt-21.02.2-ramips-mt7621-xiaomi_redmi-router-ac2100-initramfs-kernel.bin`)，点击`上传`

![Snipaste_2022-03-03_17-26-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-26-15.png)

![Snipaste_2022-03-03_17-29-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-29-15.png)

![Snipaste_2022-03-03_17-29-35](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-29-35.png)

### 5、刷入Openwrt

重启完成之后，打开192.168.1.1，进入临时系统，用户名是root，没有密码。选择要输入的固件(`openwrt-ramips-mt7621-xiaomi_redmi-router-ac2100-squashfs-sysupgrade.bin`)

![Snipaste_2022-03-03_16-08-46](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-08-46.png)

![Snipaste_2022-03-03_16-10-20](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-10-20.png)

不要勾选 `Keep settings and retain the current configuration`

![Snipaste_2022-03-03_16-15-29](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-15-29.png)

![Snipaste_2022-03-03_16-15-38](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-15-38.png)

上传后等待路由器重启

## leetcode刷题——02——循环

### 1、[剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

```C
int sumNums(int n){
    /*
    int sum=0;
    while(n){
        sum += n;
        n--;
    }
    return sum;
*/
    if(n%2==0)
        return n/2*(n+1);
    else 
        return (n+1)/2*n;
}
```

### 2、[2 的幂](https://leetcode-cn.com/problems/power-of-two/)

```C
bool isPowerOfTwo(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 1;
    while(tmp < n && i <=30 ){
        tmp *= 2;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
    
	// return (n>0)&&(n &(n-1)) == 0;		//内存消耗小
}
```

### 3、[3 的幂](https://leetcode-cn.com/problems/power-of-three/)

```C
bool isPowerOfThree(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 0;
    while(tmp < n && i <=18 ){
        tmp *= 3;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
}
```

### 4、[4的幂](https://leetcode-cn.com/problems/power-of-four/)

```C
bool isPowerOfFour(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 0;
    while(tmp < n && i <=14 ){
        tmp *= 4;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
    // return ((n>0) && (n&(n-1))==0) && (n%3==1);
}
```

### 5、[n 的第 k 个因子](https://leetcode-cn.com/problems/the-kth-factor-of-n/)

```C
int kthFactor(int n, int k){
    // int i = 1, num=0;
    // for(;i<=n;i++){
    //     if(n%i==0){
    //         num++;
    //     }
    //     if(num==k){
    //         return i;
    //     }
    // }
    // return -1;

    int i = 1;
    for(; i*i < n; i ++) {
        if((n%i == 0) && (--k == 0)) {
            return i;
        }
    }    
    if(i * i != n) {
        i --;
    }
    // from sqrt(n) again
    for(; i >= 1; i --) {
        if((n%i == 0) && (--k==0)) {
            return n/i;
        }            
    }
    return -1;
}
```

### 6、[有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

```C
bool isPerfectSquare(int num){
    // for(int i=1;num/i>=i;i++)
    //     if(num == i*i)
    //         return true;
    // return false;
    double x0 = num;
    while (true) {
        double x1 = (x0 + num / x0) / 2;
        if (x0 - x1 < 1e-6) {
            break;
        }
        x0 = x1;
    }
    int x = (int) x0;
    return x * x == num;
}
```

## VS Code连接本地WSL出现`VS Code Server for WSL closed unexpectedly.`错误

![vs_code_wsl.png](https://raw.githubusercontent.com/simoonp/picture/main/log/vs_code_wsl.png)

`临时解决方法`：

```shell
# 通过其他方式进入wsl，修改  ~/.vscode-server/bin/*******************/ 文件夹下的server.sh文件
# 在最后一行的 "$ROOT/node" ${INSPECT:-} "$ROOT/out/server-main.js" --compatibility=1.63 "$@" 中加入
# -accept-server-license-terms (这将自动接受条款，直到 MS 对其进行修补)，修改后为：
# "$ROOT/node" ${INSPECT:-} "$ROOT/out/server-main.js" --compatibility=1.63 --accept-server-license-terms "$@"
```



# 2022.03.04

## leetcode刷题——03——一维数组

### 1、[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```C
int search(int* nums, int numsSize, int target){
    // int len = numsSize;
    // int left = 0, right = len-1;
    // while(left <= right){
    //     int mid = (left + right) / 2;
    //     if(nums[mid] == target)
    //         return mid;
    //     else if(nums[mid] < nums[right]){
    //         if(nums[mid] < target && target <= nums[right])
    //             left = mid+1;
    //         else
    //             right = mid-1;
    //     }
    //     else{
    //         if(nums[left] <= target && target < nums[mid])
    //             right = mid-1;
    //         else
    //             left = mid+1;
    //     }
    // }
    // return -1;

    int left = 0, right = numsSize-1;
    int mid;
    while(left <= right){
        mid = (left+right)/2;
        if(nums[mid]==target){
            return mid;
        }
        if(nums[mid]<nums[right]){
            if(nums[mid]<target && target<=nums[right])
                left = mid+1;
            else
                right = mid-1;
        }else{
            if(nums[left]<=target && target<nums[mid])
                right = mid-1;
            else
                left = mid+1;
        }
    }
    return -1;
}
```

### 2、[搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

```C
bool search(int* nums, int numsSize, int target){
    // for(int i=0; i< numsSize; i++)
    //     if(nums[i]==target)
    //         return true;
    // return false;

    if (numsSize == 0) {
        return false;
    }
    if (numsSize == 1) {
        return nums[0] == target;
    }
    int l = 0, r = numsSize - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (nums[mid] == target) {
            return true;
        }
        if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
            ++l;
            --r;
        } else if (nums[l] <= nums[mid]) {
            if (nums[l] <= target && target < nums[mid]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[numsSize - 1]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
    }
    return false;
}
```

### 3、[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

```C
int findMin(int* nums, int numsSize){
    int low = 0;
    int high = numsSize - 1;
    while (low < high) {
        int pivot = low + (high - low) / 2;
        if (nums[pivot] < nums[high]) {
            high = pivot;
        } else {
            low = pivot + 1;
        }
    }
    return nums[low];
}
```

### 4、[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```C
int climbStairs(int n){
    // if (n==1)
    //     return 1;
    // if (n==2)
    //     return 2;
    // int i=1, j =2,sum;
    // for(int tmp=3; tmp<=n ;tmp++){
    //     sum = i+j;
    //     i=j;
    //     j=sum;
    // }
    // return j;
    
    // int p = 0, q = 0, r = 1;
    // for (int i = 1; i <= n; ++i) {
    //     p = q;
    //     q = r;
    //     r = p + q;
    // }
    // return r;
    
    // 通项公式
    double sqrt5 = sqrt(5);
    double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);
    return (int) round(fibn / sqrt5);
}
```

### 5、[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```C
int fib(int n){
    if(n){
        int p = 0, q = 0, r = 1;
        for (int i = 2; i <= n; ++i) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
    return 0;
}
```

### 6、[第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

```C
int tribonacci(int n){
    if(n){
        int p = 0, q = 1, r = 1, s = 1;
        for (int i = 3; i <= n; ++i) {
            s=p+q+r;
            p = q;
            q = r;
            r = s;
        }
        return s;
    }
    return 0;
}
```

### 7、[差的绝对值为 K 的数对数目](https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/)

```C
int countKDifference(int* nums, int numsSize, int k){
    int i,j,num=0;
    for(i=0; i<numsSize; i++){
        for(j=i+1; j<numsSize; j++){
            if(abs(nums[i]-nums[j])==k)
                num++;
        }
    }
    return num;
}
```

### 8、[ 猜数字](https://leetcode-cn.com/problems/guess-numbers/)

```C
int game(int* guess, int guessSize, int* answer, int answerSize){
    int num=0;
    for(int i=0; i<guessSize; i++){
        if(guess[i]==answer[i])
           num++; 
    }
    return num;
}
```

### 9、[拿硬币](https://leetcode-cn.com/problems/na-ying-bi/)

```C
int minCount(int* coins, int coinsSize){
    int sum=0;
    for(int i=0; i<coinsSize; i++)
        // if(coins[i]%2==)
            sum += (coins[i]+1)/2;
    return sum;
}
```

### 10、[剑指 Offer II 069. 山峰数组的顶部](https://leetcode-cn.com/problems/B1IidL/)

```C
int peakIndexInMountainArray(int* arr, int arrSize){
    int i;
    for( i=1; i<arrSize-1; i++)
        if(arr[i]>arr[i-1] && arr[i]>arr[i+1])
            break;
    return i;
}
```

# 2022.03.05

## leetcode刷题——04——指针

### [基础知识点](http://c.biancheng.net/c/pointer/)

1、定义方法：`变量类型` `*变量名`

```C
int *pa;
```

2、`*p = &普通变量名`(指针刚定义的时候可以这么写，定义完后再赋值就要`*p = 普通变量名`)，`*p = 数组名`，

使用运算符` & `求某个变量的地址，使用`*`运算符对指针取值。

```C
// 在使用已定义好的指针变量时，在变量名前面不能加 *。例如：
int *p,a;
*p=&a; //错误，指针变量是p而不是*p

int a,*p=&a; //正确 => int a; int* p=&a;
// 该语句貌似把 &a 赋给了 *p，而实际上 p 前的 * 仅是定义指针变量 p 的标识，仍然是把 &a 赋给了 p，故是正确的赋值语句。
```

```C
// 指针变量中只能保存该基类型变量的地址
int a,b,*pa,*pb;
char *pc,c;

pa=&a;	// 正确。pa基类型为int，a为int型变量，类型一致
pb=&c;	// 错误。pb基类型为int，c为char型变量，类型不一致
pc=&c;	// 正确。pc基类型为char,c为char型变量，类型一致
*pa=&a;	// 错误。指针变量是pa而非*pa
```

```C
// 指针变量的值可以改变，也即可以改变指针变量的指向
char c1,*pc,c2;//定义了字符变量c1、c2和字符指针变量pc
pc=&c1; //pc指向c1
pc=&c2; //pc不再指向c1，而指向c2
```

```C
// 同类型的指针变量可以相互赋值
int a,*p1,*p2,b;//定义了两个整型变量a,b;两个整型指针变量为p1,p2
float *pf;

p1=&a; // 地址箱p1中保存a的地址，即p1指向a
p2=p1; // p2也指向a，即p1和p2均指向a

pf=p1； // 错误。p1,pf虽然都是指针变量，但类型不同，不能赋值
pf=&b;  // 错误。指针变量pf的基类型为float，b类型为int,不相同

int a=3,*pa=&a; //pa保存变量a的地址，即指向a
char c='d',*pc=&c; //pc保存变量c的地址，即指向c
```

3、指针变量的引用

`直接访问`：知道内存空间的名字，可通过名字访问该空间，变量即代表有名字的内存单元，通过变量名操作变量，也就是通过名字直接访问该变量对应的内存单元。

`间接访问`：知道内存空间的地址，可以通过该地址间接访问该空间，对内存空间的访问操作一般指的是存、取操作，即向内存空间中存入数据和从内存空间中读取数据。

使用间接访问符（取内容访问符）`*`来访问指针所指向的空间

```C
int *p,a=3; //p中保存变量a对应内存单元的地址
p=&a;
printf("a=%d\n",a); //通过名字，直接访问变量a空间（读取）
printf("a=%d\n",*p); //通过地址，间接访问变量a空间（读取）
*p=6;//等价于a=6;间接访问a对应空间（存）
```

4、野指针

`野指针`：没有合法指向的指针，“野”指针随机指向一块空间，该空间中存储的可能是其他程序的数据甚至是系统数据，故不能对“野”指针所指向的空间进行存取操作，否则轻者会引起程序崩溃，严重的可能导致整个系统崩溃。

```C
int *pi,a; //pi未初始化，无合法指向，为“野”指针

*pi=3; //运行时错误！不能对”野”指针指向的空间做存入操作。该语句试图把 3 存入“野”指针pi所指的随机空间中，会产生运行时错误。
a=*pi; //运行时错误！不能对”野”指针指向的空间取操作。该语句试图从“野”指针pi所指的空间中取出数据，然后赋给变量a同样会产生运行时错误。

// 正确用法：
pi=&a;//让pi有合法的指向，pi指向a变量对应的空间
*pi=3;//把3间接存入pi所指向的变量a对应的空间
```

### 1、[重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* shuffle(int* nums, int numsSize, int n, int* returnSize){
    int i;
    int *ret=(int *)malloc(sizeof(int) * numsSize);
    for(i=0;i<numsSize;i++)
        if(i%2)
            ret[i]=nums[n+i/2];
        else
            ret[i]=nums[(i+1)/2];
    *returnSize = numsSize;
    return ret;
}
```

# 2022.03.06

### 2、[数组串联](https://leetcode-cn.com/problems/concatenation-of-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* getConcatenation(int* nums, int numsSize, int* returnSize){
    // int i=0;
    // int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    // for(;i<numsSize;i++){
    //     *(ret+numsSize)=*nums;
    //     *ret++=*nums++;
    // }
    // *returnSize=2*numsSize;
    // return ret-numsSize;


    int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    int *tmp=ret;
    while(ret<tmp+numsSize){
        *(ret+numsSize)=*nums;
        *ret++=*nums++;
    }
    *returnSize=2*numsSize;
    return ret-numsSize;

    // int i=0;
    // int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    // for(;i<numsSize;i++){
    //     ret[i+numsSize]=ret[i]=nums[i];
    // }

    // *returnSize=2*numsSize;
    // return ret;
}
```

### 3、[基于排列构建数组](https://leetcode-cn.com/problems/build-array-from-permutation/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* buildArray(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)(malloc)(sizeof(int)*numsSize);
    // int *tmp=ret+numsSize;
    int i=0;
    // while(i<numsSize)
    //     *ret++=nums[nums[i++]];
    while(i<numsSize){
        ret[i]=nums[nums[i]];
        i++;
    }
    *returnSize=numsSize;
    return ret;
}
```

### 4、[一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* runningSum(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0;i<numsSize;i++){
        ret[i]=nums[i];
        if(i)
            ret[i]+=ret[i-1];
    }
    *returnSize=numsSize;
    return ret;
    
    for(int i=1; i<numsSize; i++)
        nums[i] += nums[i-1];

    *returnSize=numsSize;
    return nums;
}
```

### 5、[左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```C
char* reverseLeftWords(char* s, int k){
    int i;
    int n = strlen(s);
    char *ret = (char *)malloc( (n + 1) * sizeof(char) );    // (1)
    for(i = 0; i < n; ++i) {
        ret[i] = s[(i + k) % n];                             // (2)
    }
    ret[n] = '\0';                                           // (3)
    return ret;
}
```

### 6、[IP 地址无效化](https://leetcode-cn.com/problems/defanging-an-ip-address/)

```C
char * defangIPaddr(char * address){
    char *ret=(char *)malloc(sizeof(char)*23);
    int i=0;
    do{
        i +=1;
        if(*address == '.'){
            i+=2;
            *ret++ = '[';
            *ret++ = '.';
            *ret++ = ']';
        }else
            *ret++=*address;
    }while(*address++ != '\0');
    *ret='\0';
    return ret-i;
}
```

### 7、[ 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```C
char* replaceSpace(char* s){
    char *ret=(char *)malloc(sizeof(char)*300001);
    int i=0;
    do{
        if(*s == ' '){
            *ret++ = '%%';
            *ret++ = '2';
            *ret++ = '0';
            i+=3;
        }else{
            i++;
            *ret++=*s;
        }
    }while(*s++ );
    *ret = '\0';
    return ret-i;
}
```

### 8、[有多少小于当前数字的数字](https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    
    for(int i=0;i<numsSize;i++){
        int sum=0;
        for(int j=0; j<numsSize;j++)
            if(j!=i)
                if(nums[j]<nums[i])
                    sum++;
        ret[i]=sum;
    }
    *returnSize = numsSize;
    return ret;
}
```

### 9、[打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* printNumbers(int n, int* returnSize){
    int len=1;
    for(int i=0; i<n; i++)
        len *= 10;
    len--;
    int *ret = (int *)malloc(sizeof(int)*(len));
    for(int i=0; i<len; i++)
        ret[i]=i+1;
    *returnSize = len;
    return ret;
}
```

### 10、[按既定顺序创建目标数组](https://leetcode-cn.com/problems/create-target-array-in-the-given-order/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize){
    int *target=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0; i<numsSize; i++){
        for(int j=i; j>index[i]; j--)
            target[j]=target[j-1];
        target[index[i]]=nums[i];
    }
    *returnSize = numsSize;
    return target;
}
```


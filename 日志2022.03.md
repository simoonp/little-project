# 2022.03.01

## 上传GitHub，git push失败

失败提示： `gnutls_handshake() failed: The TLS connection was non-properly terminated.`

1、重置代理
```shell
git config --global  --unset https.https://github.com.proxy 
git config --global  --unset http.https://github.com.proxy 
```

2、重新设置账户
```shell
git config --global user.name "xxx"
git config --global user.email "xxxx"
```

3、重新申请token

4、git push时输入新的token

## U盘被分区后，重新格式化成一个盘

1、Win + R，输入CMD，打开Windows终端

2、输入 `diskpart` 指令，弹出新窗口

3、输入 `list disk` 列出所有磁盘

4、输入 `select disk 磁盘序号` 选择磁盘

5、输入 `clean` 清除分区，然后就可以在磁盘管理器里面看到一块未格式化的磁盘

![Image](https://raw.githubusercontent.com/simoonp/picture/main/log/disk.png)


## git删除远程文件
```shell
git rm --cached 文件名
```

## 微星主板刷BIOS

1、在微星官网下载BIOS文件，将压缩包内的 `.2E0` 文件重命名为 `MSI.ROM` 复制到FAT32格式U盘的根目录下

(注：部分劣质U盘，主板可能无法识别)

2、将主板插上24Pin主板供电和8Pin供电，电源上电，主机开关不用开启

3、将U盘插到主板带有BIOS或Flash字样的USB口（没有标注的查阅说明书或询问客服），长按BIOS刷写按钮3秒然后松开，当红灯开始闪烁说明正在搜索BIOS文件，红灯快速闪烁说明正在写入BIOS，指示灯熄灭表示写入完毕(也可能写入完毕后指示灯常亮)。

## 京东脚本库
```shell
1、
ql repo https://github.com/zero205/JD_tencent_scf.git "jd_|jx_|jdCookie" "backUp|icon" "^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql" "main"
2、
ql repo https://github.com/atyvcn/jd_scripts.git "jd_|jx_|ty_|CheckRpeat" "activity|backUp|icon" "^jd[^_]|^JD|USER|utils|function|^sign|sendNotify"
3、
ql repo https://github.com/smiek2221/scripts.git "jd_|gua_" "" "ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js"

4、
ql repo https://github.com/he1pu/JDHelp.git "jd_|jx_|getJDCookie" "activity|backUp|jd_delCoupon" "^jd[^_]|USER"
```

## leetcode刷题——01——函数

### 1、[两整数求和](https://leetcode-cn.com/problems/sum-of-two-integers/)，[面试题 17.01. 不用加号的加法](https://leetcode-cn.com/problems/add-without-plus-lcci/)，[剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```C
int add(int a, int b){
    if(b == 0)
        return a;
    return add(a^b,(a&(b&0xffffffff))<<1);
    // 为啥b加上0xffffffff后就不报错了？
    // LC C/C++不支持负值左移，需要强制转换为无符号数
    // return add(a^b,(unsigned int)(a&(b))<<1);
}
```
### 2、[递归乘法](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

```C
int multiply(int A, int B){
    //return A*B;

    // if(B==0)
    //     return 0;
    // int temp_a=A;
    // if(B>0){
    //     while(B>1){
    //         A += temp_a;
    //         B--;
    //     }
    // }else if(B<0){
    //     while(B<-1){
    //         A += temp_a;
    //         B++;
    //     }
    // }
    // return A;
       
    if (B==0)
        return 0;
    if (B>1)
        return A + multiply(A, B-1);
    else if(B<-1)
        return A + multiply(A, B+1);
    return A;

}
```

### 3、[Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

```C
double myPow(double x, int n){
    double res = 1;
    int i = n;
    while(i){
        if(i%2)
            res *= x;
 
        x *= x;

        i /= 2;
    }

    // double res = 1.0;
    // for(int i = n; i != 0; i /= 2){
    //     if(i % 2 != 0){
    //         res *= x;
    //     }
    //     x *= x;
    // }

    return  n < 0 ? 1 / res : res;

}
```

### 4、[x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

```C
int mySqrt(int x){
    // return sqrt(x);

    // int i=1, tmp = 1;
    // while(tmp<46340 && i<x){
    //     tmp++;
    //     i = tmp*tmp;
    // }
    // if(i > x)
    //     tmp--;
    // return tmp;

    // 牛顿迭代法
    if(x == 1)
        return 1;
    int min = 0;
    int max = x;
    while(max-min>1)
    {
        int m = (max+min)/2;
        if(x/m<m)
            max = m;
        else
            min = m;
    }
    return min;
}
```

### 5、[面试题 16.07. 最大数值](https://leetcode-cn.com/problems/maximum-lcci/)

```C
int maximum(int a, int b){
// a < b:
// 1 + (a - b) >> 31 == 0
// a > b:
// 1 + (a - b) >> 31 == 1

    long c = a, d = b;
    int k = 1 + ((c - d) >> 63);
    return k * a + (!k) * b;
}
```

### 6、[2119. 反转两次的数字](https://leetcode-cn.com/problems/a-number-after-a-double-reversal/)

```C
bool isSameAfterReversals(int num){
    if(num==0 || num%10)
        return true;
    return false;
}
```



# 2022.03.03

## 刷机 Redmi AC2100

### 需要的固件

`ac2100 breed` breed-mt7621-xiaomi-r3g.bin

`AC2100 2.0.7 旧固件` miwifi_rm2100_firmware_d6234_2.0.7.bin

`OpenWRT临时固件` openwrt-21.02.2-ramips-mt7621-xiaomi_redmi-router-ac2100-initramfs-kernel.bin

`Openwrt系统固件` openwrt-ramips-mt7621-xiaomi_redmi-router-ac2100-squashfs-sysupgrade.bin

scp -r breed-mt7621-xiaomi-r3g.bin root@192.168.31.1:/tmp/

### 1、系统降级

完成路由器的基本设置(设置密码)，登录路由器管理界面，在页面右上角，系统升级的位置，选择手动升级，选择下载的`miwifi_rm2100_firmware_d6234_2.0.7.bin`旧系统固件，完成后等待系统自动重启

![Snipaste_2022-03-03_17-10-30](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-10-30.png)

### 2、开启SSH

重新完成路由器基本设置，登录路由器后台，看浏览器地址连的url地址，记录stok后面的一串字符

```C
// ip可能会不一样，<stok>是一长串字符每次登录后都不一样
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/web/home#router
```

![Snipaste_2022-03-03_14-37-53](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-37-53.png)

使用下述代码进行注入，将`<stok>`替换为浏览器地址栏显示的值后再输入进地址栏

```c
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B
```

![Snipaste_2022-03-03_14-39-10](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-39-10.png)

输入地址，回车后，浏览器会显示`{"code":0}`

![Snipaste_2022-03-03_14-42-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-42-15.png)

退出再刷新浏览器重新进入管理界面，此时`<stok>`会发生变化，再通过下述代码修改root密码：

![Snipaste_2022-03-03_14-43-09](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-43-09.png)

```C
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B
```

![Snipaste_2022-03-03_14-44-49](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-44-49.png)

此时能够使用ssh登录进路由器，账号为：root 密码为：admin

使用CMD控制台ssh进入路由器系统(路由器IP：192.168.31.1)

![Snipaste_2022-03-03_14-46-09](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-46-09.png)

### 3、刷入breed

新开一个CMD窗口，通过scp指令远程上传文件到路由器`/tmp/`文件夹

![Snipaste_2022-03-03_14-54-27](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-54-27.png)

备份路由器原来的分区文件

![Snipaste_2022-03-03_15-20-03](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-20-03.png)

```shell
# 在路由器终端输入
dd if=/dev/mtd0 of=/tmp/all.bin
dd if=/dev/mtd1 of=/tmp/bootloader.bin
dd if=/dev/mtd4 of=/tmp/eeprom.bin
```

将备份的文件下载到本地

```shell
# 在Windows的CMD控制台输入：
scp root@192.168.31.1:/tmp/all.bin .
scp root@192.168.31.1:/tmp/bootloader.bin .
scp root@192.168.31.1:/tmp/eeprom.bin .
```

![Snipaste_2022-03-03_17-19-48](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-19-48.png)

![Snipaste_2022-03-03_15-21-32](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-21-32.png)

在路由器终端执行：

```she
mtd -r write /tmp/breed-mt7621-xiaomi-r3g.bin Bootloader
```

![Snipaste_2022-03-03_15-23-03](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-23-03.png)

### 4、刷入临时系统

如果电脑重新获取到IP后说明刷写完成并且breed引导了官方固件，断电。按住reset键（背面圆孔，用取卡针插进去）后插电等待system的蓝灯闪烁后松开reset键。

用浏览器访问`192.168.1.1`进入breed恢复界面，更改环境变量，新增字段"xiaomi.r3g.bootfw", 值设置为 2,然后保存。

![Snipaste_2022-03-03_15-26-44](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-26-44.png)

![Snipaste_2022-03-03_15-28-53](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-28-53.png)



点击固件更新，上传自己的固件(选择 `openwrt-21.02.2-ramips-mt7621-xiaomi_redmi-router-ac2100-initramfs-kernel.bin`)，点击`上传`

![Snipaste_2022-03-03_17-26-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-26-15.png)

![Snipaste_2022-03-03_17-29-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-29-15.png)

![Snipaste_2022-03-03_17-29-35](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-29-35.png)

### 5、刷入Openwrt

重启完成之后，打开192.168.1.1，进入临时系统，用户名是root，没有密码。选择要输入的固件(`openwrt-ramips-mt7621-xiaomi_redmi-router-ac2100-squashfs-sysupgrade.bin`)

![Snipaste_2022-03-03_16-08-46](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-08-46.png)

![Snipaste_2022-03-03_16-10-20](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-10-20.png)

不要勾选 `Keep settings and retain the current configuration`

![Snipaste_2022-03-03_16-15-29](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-15-29.png)

![Snipaste_2022-03-03_16-15-38](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-15-38.png)

上传后等待路由器重启

## leetcode刷题——02——循环

### 1、[剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

```C
int sumNums(int n){
    /*
    int sum=0;
    while(n){
        sum += n;
        n--;
    }
    return sum;
*/
    if(n%2==0)
        return n/2*(n+1);
    else 
        return (n+1)/2*n;
}
```

### 2、[2 的幂](https://leetcode-cn.com/problems/power-of-two/)

```C
bool isPowerOfTwo(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 1;
    while(tmp < n && i <=30 ){
        tmp *= 2;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
    
	// return (n>0)&&(n &(n-1)) == 0;		//内存消耗小
}
```

### 3、[3 的幂](https://leetcode-cn.com/problems/power-of-three/)

```C
bool isPowerOfThree(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 0;
    while(tmp < n && i <=18 ){
        tmp *= 3;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
}
```

### 4、[4的幂](https://leetcode-cn.com/problems/power-of-four/)

```C
bool isPowerOfFour(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 0;
    while(tmp < n && i <=14 ){
        tmp *= 4;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
    // return ((n>0) && (n&(n-1))==0) && (n%3==1);
}
```

### 5、[n 的第 k 个因子](https://leetcode-cn.com/problems/the-kth-factor-of-n/)

```C
int kthFactor(int n, int k){
    // int i = 1, num=0;
    // for(;i<=n;i++){
    //     if(n%i==0){
    //         num++;
    //     }
    //     if(num==k){
    //         return i;
    //     }
    // }
    // return -1;

    int i = 1;
    for(; i*i < n; i ++) {
        if((n%i == 0) && (--k == 0)) {
            return i;
        }
    }    
    if(i * i != n) {
        i --;
    }
    // from sqrt(n) again
    for(; i >= 1; i --) {
        if((n%i == 0) && (--k==0)) {
            return n/i;
        }            
    }
    return -1;
}
```

### 6、[有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

```C
bool isPerfectSquare(int num){
    // for(int i=1;num/i>=i;i++)
    //     if(num == i*i)
    //         return true;
    // return false;
    double x0 = num;
    while (true) {
        double x1 = (x0 + num / x0) / 2;
        if (x0 - x1 < 1e-6) {
            break;
        }
        x0 = x1;
    }
    int x = (int) x0;
    return x * x == num;
}
```

## VS Code连接本地WSL出现`VS Code Server for WSL closed unexpectedly.`错误

![vs_code_wsl.png](https://raw.githubusercontent.com/simoonp/picture/main/log/vs_code_wsl.png)

`临时解决方法`：

```shell
# 通过其他方式进入wsl，修改  ~/.vscode-server/bin/*******************/ 文件夹下的server.sh文件
# 在最后一行的 "$ROOT/node" ${INSPECT:-} "$ROOT/out/server-main.js" --compatibility=1.63 "$@" 中加入
# -accept-server-license-terms (这将自动接受条款，直到 MS 对其进行修补)，修改后为：
# "$ROOT/node" ${INSPECT:-} "$ROOT/out/server-main.js" --compatibility=1.63 --accept-server-license-terms "$@"
```



# 2022.03.04

## leetcode刷题——03——一维数组

### 1、[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```C
int search(int* nums, int numsSize, int target){
    // int len = numsSize;
    // int left = 0, right = len-1;
    // while(left <= right){
    //     int mid = (left + right) / 2;
    //     if(nums[mid] == target)
    //         return mid;
    //     else if(nums[mid] < nums[right]){
    //         if(nums[mid] < target && target <= nums[right])
    //             left = mid+1;
    //         else
    //             right = mid-1;
    //     }
    //     else{
    //         if(nums[left] <= target && target < nums[mid])
    //             right = mid-1;
    //         else
    //             left = mid+1;
    //     }
    // }
    // return -1;

    int left = 0, right = numsSize-1;
    int mid;
    while(left <= right){
        mid = (left+right)/2;
        if(nums[mid]==target){
            return mid;
        }
        if(nums[mid]<nums[right]){
            if(nums[mid]<target && target<=nums[right])
                left = mid+1;
            else
                right = mid-1;
        }else{
            if(nums[left]<=target && target<nums[mid])
                right = mid-1;
            else
                left = mid+1;
        }
    }
    return -1;
}
```

### 2、[搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

```C
bool search(int* nums, int numsSize, int target){
    // for(int i=0; i< numsSize; i++)
    //     if(nums[i]==target)
    //         return true;
    // return false;

    if (numsSize == 0) {
        return false;
    }
    if (numsSize == 1) {
        return nums[0] == target;
    }
    int l = 0, r = numsSize - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (nums[mid] == target) {
            return true;
        }
        if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
            ++l;
            --r;
        } else if (nums[l] <= nums[mid]) {
            if (nums[l] <= target && target < nums[mid]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[numsSize - 1]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
    }
    return false;
}
```

### 3、[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

```C
int findMin(int* nums, int numsSize){
    int low = 0;
    int high = numsSize - 1;
    while (low < high) {
        int pivot = low + (high - low) / 2;
        if (nums[pivot] < nums[high]) {
            high = pivot;
        } else {
            low = pivot + 1;
        }
    }
    return nums[low];
}
```

### 4、[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```C
int climbStairs(int n){
    // if (n==1)
    //     return 1;
    // if (n==2)
    //     return 2;
    // int i=1, j =2,sum;
    // for(int tmp=3; tmp<=n ;tmp++){
    //     sum = i+j;
    //     i=j;
    //     j=sum;
    // }
    // return j;
    
    // int p = 0, q = 0, r = 1;
    // for (int i = 1; i <= n; ++i) {
    //     p = q;
    //     q = r;
    //     r = p + q;
    // }
    // return r;
    
    // 通项公式
    double sqrt5 = sqrt(5);
    double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);
    return (int) round(fibn / sqrt5);
}
```

### 5、[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```C
int fib(int n){
    if(n){
        int p = 0, q = 0, r = 1;
        for (int i = 2; i <= n; ++i) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
    return 0;
}
```

### 6、[第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

```C
int tribonacci(int n){
    if(n){
        int p = 0, q = 1, r = 1, s = 1;
        for (int i = 3; i <= n; ++i) {
            s=p+q+r;
            p = q;
            q = r;
            r = s;
        }
        return s;
    }
    return 0;
}
```

### 7、[差的绝对值为 K 的数对数目](https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/)

```C
int countKDifference(int* nums, int numsSize, int k){
    int i,j,num=0;
    for(i=0; i<numsSize; i++){
        for(j=i+1; j<numsSize; j++){
            if(abs(nums[i]-nums[j])==k)
                num++;
        }
    }
    return num;
}
```

### 8、[ 猜数字](https://leetcode-cn.com/problems/guess-numbers/)

```C
int game(int* guess, int guessSize, int* answer, int answerSize){
    int num=0;
    for(int i=0; i<guessSize; i++){
        if(guess[i]==answer[i])
           num++; 
    }
    return num;
}
```

### 9、[拿硬币](https://leetcode-cn.com/problems/na-ying-bi/)

```C
int minCount(int* coins, int coinsSize){
    int sum=0;
    for(int i=0; i<coinsSize; i++)
        // if(coins[i]%2==)
            sum += (coins[i]+1)/2;
    return sum;
}
```

### 10、[剑指 Offer II 069. 山峰数组的顶部](https://leetcode-cn.com/problems/B1IidL/)

```C
int peakIndexInMountainArray(int* arr, int arrSize){
    int i;
    for( i=1; i<arrSize-1; i++)
        if(arr[i]>arr[i-1] && arr[i]>arr[i+1])
            break;
    return i;
}
```

# 2022.03.05

## leetcode刷题——04——指针

### [基础知识点](http://c.biancheng.net/c/pointer/)

1、定义方法：`变量类型` `*变量名`

```C
int *pa;
```

2、`*p = &普通变量名`(指针刚定义的时候可以这么写，定义完后再赋值就要`*p = 普通变量名`)，`*p = 数组名`，

使用运算符` & `求某个变量的地址，使用`*`运算符对指针取值。

```C
// 在使用已定义好的指针变量时，在变量名前面不能加 *。例如：
int *p,a;
*p=&a; //错误，指针变量是p而不是*p

int a,*p=&a; //正确 => int a; int* p=&a;
// 该语句貌似把 &a 赋给了 *p，而实际上 p 前的 * 仅是定义指针变量 p 的标识，仍然是把 &a 赋给了 p，故是正确的赋值语句。
```

```C
// 指针变量中只能保存该基类型变量的地址
int a,b,*pa,*pb;
char *pc,c;

pa=&a;	// 正确。pa基类型为int，a为int型变量，类型一致
pb=&c;	// 错误。pb基类型为int，c为char型变量，类型不一致
pc=&c;	// 正确。pc基类型为char,c为char型变量，类型一致
*pa=&a;	// 错误。指针变量是pa而非*pa
```

```C
// 指针变量的值可以改变，也即可以改变指针变量的指向
char c1,*pc,c2;//定义了字符变量c1、c2和字符指针变量pc
pc=&c1; //pc指向c1
pc=&c2; //pc不再指向c1，而指向c2
```

```C
// 同类型的指针变量可以相互赋值
int a,*p1,*p2,b;//定义了两个整型变量a,b;两个整型指针变量为p1,p2
float *pf;

p1=&a; // 地址箱p1中保存a的地址，即p1指向a
p2=p1; // p2也指向a，即p1和p2均指向a

pf=p1； // 错误。p1,pf虽然都是指针变量，但类型不同，不能赋值
pf=&b;  // 错误。指针变量pf的基类型为float，b类型为int,不相同

int a=3,*pa=&a; //pa保存变量a的地址，即指向a
char c='d',*pc=&c; //pc保存变量c的地址，即指向c
```

3、指针变量的引用

`直接访问`：知道内存空间的名字，可通过名字访问该空间，变量即代表有名字的内存单元，通过变量名操作变量，也就是通过名字直接访问该变量对应的内存单元。

`间接访问`：知道内存空间的地址，可以通过该地址间接访问该空间，对内存空间的访问操作一般指的是存、取操作，即向内存空间中存入数据和从内存空间中读取数据。

使用间接访问符（取内容访问符）`*`来访问指针所指向的空间

```C
int *p,a=3; //p中保存变量a对应内存单元的地址
p=&a;
printf("a=%d\n",a); //通过名字，直接访问变量a空间（读取）
printf("a=%d\n",*p); //通过地址，间接访问变量a空间（读取）
*p=6;//等价于a=6;间接访问a对应空间（存）
```

4、野指针

`野指针`：没有合法指向的指针，“野”指针随机指向一块空间，该空间中存储的可能是其他程序的数据甚至是系统数据，故不能对“野”指针所指向的空间进行存取操作，否则轻者会引起程序崩溃，严重的可能导致整个系统崩溃。

```C
int *pi,a; //pi未初始化，无合法指向，为“野”指针

*pi=3; //运行时错误！不能对”野”指针指向的空间做存入操作。该语句试图把 3 存入“野”指针pi所指的随机空间中，会产生运行时错误。
a=*pi; //运行时错误！不能对”野”指针指向的空间取操作。该语句试图从“野”指针pi所指的空间中取出数据，然后赋给变量a同样会产生运行时错误。

// 正确用法：
pi=&a;//让pi有合法的指向，pi指向a变量对应的空间
*pi=3;//把3间接存入pi所指向的变量a对应的空间
```

### 1、[重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* shuffle(int* nums, int numsSize, int n, int* returnSize){
    int i;
    int *ret=(int *)malloc(sizeof(int) * numsSize);
    for(i=0;i<numsSize;i++)
        if(i%2)
            ret[i]=nums[n+i/2];
        else
            ret[i]=nums[(i+1)/2];
    *returnSize = numsSize;
    return ret;
}
```

# 2022.03.06

### 2、[数组串联](https://leetcode-cn.com/problems/concatenation-of-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* getConcatenation(int* nums, int numsSize, int* returnSize){
    // int i=0;
    // int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    // for(;i<numsSize;i++){
    //     *(ret+numsSize)=*nums;
    //     *ret++=*nums++;
    // }
    // *returnSize=2*numsSize;
    // return ret-numsSize;


    int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    int *tmp=ret;
    while(ret<tmp+numsSize){
        *(ret+numsSize)=*nums;
        *ret++=*nums++;
    }
    *returnSize=2*numsSize;
    return ret-numsSize;

    // int i=0;
    // int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    // for(;i<numsSize;i++){
    //     ret[i+numsSize]=ret[i]=nums[i];
    // }

    // *returnSize=2*numsSize;
    // return ret;
}
```

### 3、[基于排列构建数组](https://leetcode-cn.com/problems/build-array-from-permutation/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* buildArray(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)(malloc)(sizeof(int)*numsSize);
    // int *tmp=ret+numsSize;
    int i=0;
    // while(i<numsSize)
    //     *ret++=nums[nums[i++]];
    while(i<numsSize){
        ret[i]=nums[nums[i]];
        i++;
    }
    *returnSize=numsSize;
    return ret;
}
```

### 4、[一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* runningSum(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0;i<numsSize;i++){
        ret[i]=nums[i];
        if(i)
            ret[i]+=ret[i-1];
    }
    *returnSize=numsSize;
    return ret;
    
    for(int i=1; i<numsSize; i++)
        nums[i] += nums[i-1];

    *returnSize=numsSize;
    return nums;
}
```

### 5、[左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```C
char* reverseLeftWords(char* s, int k){
    int i;
    int n = strlen(s);
    char *ret = (char *)malloc( (n + 1) * sizeof(char) );    // (1)
    for(i = 0; i < n; ++i) {
        ret[i] = s[(i + k) % n];                             // (2)
    }
    ret[n] = '\0';                                           // (3)
    return ret;
}
```

### 6、[IP 地址无效化](https://leetcode-cn.com/problems/defanging-an-ip-address/)

```C
char * defangIPaddr(char * address){
    char *ret=(char *)malloc(sizeof(char)*23);
    int i=0;
    do{
        i +=1;
        if(*address == '.'){
            i+=2;
            *ret++ = '[';
            *ret++ = '.';
            *ret++ = ']';
        }else
            *ret++=*address;
    }while(*address++ != '\0');
    *ret='\0';
    return ret-i;
}
```

### 7、[ 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```C
char* replaceSpace(char* s){
    char *ret=(char *)malloc(sizeof(char)*300001);
    int i=0;
    do{
        if(*s == ' '){
            *ret++ = '%%';
            *ret++ = '2';
            *ret++ = '0';
            i+=3;
        }else{
            i++;
            *ret++=*s;
        }
    }while(*s++ );
    *ret = '\0';
    return ret-i;
}
```

### 8、[有多少小于当前数字的数字](https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    
    for(int i=0;i<numsSize;i++){
        int sum=0;
        for(int j=0; j<numsSize;j++)
            if(j!=i)
                if(nums[j]<nums[i])
                    sum++;
        ret[i]=sum;
    }
    *returnSize = numsSize;
    return ret;
}
```

### 9、[打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* printNumbers(int n, int* returnSize){
    int len=1;
    for(int i=0; i<n; i++)
        len *= 10;
    len--;
    int *ret = (int *)malloc(sizeof(int)*(len));
    for(int i=0; i<len; i++)
        ret[i]=i+1;
    *returnSize = len;
    return ret;
}
```

### 10、[按既定顺序创建目标数组](https://leetcode-cn.com/problems/create-target-array-in-the-given-order/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize){
    int *target=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0; i<numsSize; i++){
        for(int j=i; j>index[i]; j--)
            target[j]=target[j-1];
        target[index[i]]=nums[i];
    }
    *returnSize = numsSize;
    return target;
}
```

# 2022.03.07

## leetcode刷题——05——排序API

### 1、[排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int cmp(const void*a, const void* b){
    return *(int *)a - *(int *)b;
}
int* sortArray(int* nums, int numsSize, int* returnSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    *returnSize = numsSize;
    return nums;
}
```

### 2、[多数元素](https://leetcode-cn.com/problems/majority-element/)

```C
int cmp(const void* a, const void* b){
    return (*(int *)a) - (*(int *)b);
}
int majorityElement(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums[numsSize/2];
}
```

### 3、[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

```C
int cmp(const void* a, const void* b){
    return (*(int *)a) - (*(int *)b);
}
int majorityElement(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums[numsSize/2];
}
```

### 4、[最大间距](https://leetcode-cn.com/problems/maximum-gap/)

```C
int cmp(const void* a, const void *b){
    return (*(int *)a) - (*(int *)b);
}
int maximumGap(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int max=0;
    for(int i=0; i<numsSize-1; i++){
        if(nums[i+1]-nums[i]>max){
            max = nums[i+1]-nums[i];
        }
    }
    return max;
}
```

### 5、[按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int Qua(int x){
    return x&1;
}
int cmp(const void *a, const void *b){
    return Qua(*(int *)a) - Qua(*(int *)b);
}
int* sortArrayByParity(int* nums, int numsSize, int* returnSize){
    int i;
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    for(i=0; i<numsSize; i++){
        ret[i]=nums[i];
    }
    qsort(ret, numsSize, sizeof(int), cmp);
    *returnSize = numsSize;
    return ret;
}
```

### 6、[最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

```C
int cmp(const void* a, const void* b){
    return *(int *)a - *(int *)b;
}

int min(int a, int b){
    return a<b ? a : b;
}
int findMinDifference(char ** timePoints, int timePointsSize){
    int *ret=(int *)malloc(sizeof(int)*timePointsSize);
    int a,b,i;
    int ans=1440;
    for( i=0; i<timePointsSize; i++){
        sscanf(timePoints[i], "%d:%d",&a, &b);
        ret[i]=a*60 + b;
    }

    qsort(ret, timePointsSize, sizeof(int), cmp);

    for( i=1; i<timePointsSize; i++){
        ans=min(ans, ret[i]-ret[i-1]);
    }
    ans=min(ans, 1440-ret[timePointsSize-1]+ret[0]);
    return ans;
}
```

### 7、[三角形的最大周长](https://leetcode-cn.com/problems/largest-perimeter-triangle/)

```C
int cmp(const void* a, const *b)
{
    return *(int *)a - *(int *)b;
}
int largestPerimeter(int* nums, int numsSize){
    // int len=0;
    qsort(nums, numsSize, sizeof(int), cmp);
    for(int i=numsSize-1; i>1; i--)
        if(nums[i]<(nums[i-1]+nums[i-2]))
            return nums[i]+nums[i-1]+nums[i-2];
    return 0;
}
```

### 8、[救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)

```C
int cmp(const void* a, const void* b){
    return *(int *)a - *(int *)b;
}
int numRescueBoats(int* people, int peopleSize, int limit){
    qsort(people,peopleSize,sizeof(int),cmp);
    int num=0;
    int i;
    int l=0,r=peopleSize-1;
    while(l<=r){
        if(l==r){
            num++;
            break;
        }else if(people[l]+people[r]>limit){
            num++;
            r--;
        }else{
            num++;
            l++;
            r--;
        }
    }
    return num;
}
```

# 2022.03.11

## leetcode刷题——06——贪心

### 1、[两个数对之间的最大乘积差](https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int maxProductDifference(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums[numsSize-1]*nums[numsSize-2] - nums[0]*nums[1];
}
```

### 3、[数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int arrayPairSum(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int ret = 0;
    for(int i=0; i<numsSize; ){
        ret += nums[i];
        i+=2;
    }
    return ret;
}
```

### 5、[摆动排序 II](https://leetcode-cn.com/problems/wiggle-sort-ii/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}
void wiggleSort(int* nums, int numsSize){
    int *ret = (int *)malloc(sizeof(int) * numsSize);
    for(int i=0; i<numsSize; i++)
        ret[i]=nums[i];
    qsort(ret, numsSize, sizeof(int), cmp);
    int r=numsSize-1;
    for(int i=1; i<numsSize; i+=2)
        nums[i] = ret[r--];
    for(int i=0; i<numsSize; i+=2)
        nums[i] = ret[r--]; 
}
```

### 6、[分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a-*(int *)b;
}
int findContentChildren(int* g, int gSize, int* s, int sSize){
    qsort(g, gSize, sizeof(int), cmp);
    qsort(s, sSize, sizeof(int), cmp);
    int ans=0;
    int j=sSize-1, i=gSize-1;
 
    while(i>=0 && j>=0)
        if(s[j]>=g[i]){
            j--;
            i--;
            ans++;
        }else{
            i--;
        }
    return ans;
}
```

### 7、[最少操作使数组递增](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing/)

```C
int minOperations(int* nums, int numsSize){
    int i=0, ans=0, pre=nums[0]+1;
    for(i=1; i<numsSize; i++){
        if(pre < nums[i])
            pre = nums[i]+1;
        else{
            ans += pre - nums[i];
            pre++;
        }
    }
    return ans;
}
```

### 8、[使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a-*(int *)b;
}
// int min(int a, int b){
//     return a<b ? a : b;
// }
// int minIncrementForUnique(int* nums, int numsSize){
//     int * ret=(int *)malloc(sizeof(int)*numsSize);
//     for(int i=0;i<numsSize;i++)
//         ret[i]=nums[i];
//     qsort(ret, numsSize, sizeof(int), cmp);
//     int taken=0, ans=0;
//     for(int i=1; i<numsSize; i++){
//         if(ret[i-1]==ret[i]){
//             taken++;
//             ans = ans-ret[i];
//         }else{
//             int give=min(taken, ret[i]-ret[i-1]-1);
//             ans += give*(give+1)/2+give*ret[i-1];
//             taken -= give;
//         }
//     }
//     if(taken>0)
//         ans += taken*(taken+1)/2+taken*ret[numsSize-1];
//     return ans;
// }

int minIncrementForUnique(int* nums, int numsSize){
    int * ret=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0;i<numsSize;i++)
        ret[i]=nums[i];
    qsort(ret, numsSize, sizeof(int), cmp);
    int move=0;
    for(int i=1; i<numsSize; i++){
        if(ret[i] <= ret[i-1]){
            int pre=ret[i];
            ret[i] = ret[i-1]+1;
            move += ret[i] - pre;
        }
    }
    return move;
}
```

### 9、[有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int triangleNumber(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int i,j,k, ans=0;
    for(i=0; i<numsSize; i++){
        j=i+1;
        k=j+1;
        while(j<numsSize){
            while(k<numsSize){
                if(nums[i]+nums[j] <= nums[k]){
                    break;
                }
                k++;
            }
            ans += k-j-1;
            j++;
            if(k == j)
                k++;
        }
    }
    return ans;
}
```

## leetcode刷题——07——二位数组

# 2022.03.12

### 1、[统计有序矩阵中的负数](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/)

```C
int countNegatives(int** grid, int gridSize, int* gridColSize){
    int r=gridSize, l=gridColSize[0];
    int ans=0;
    for(int i=0; i<r; i++){
        for(int j=0; j<l; j++){
            if(grid[i][j]<0)
                ans++;
        }
    }
    return ans;
}
```

### 2、[矩阵对角线元素的和](https://leetcode-cn.com/problems/matrix-diagonal-sum/)

```C
int diagonalSum(int** mat, int matSize, int* matColSize){
    int r=matSize, l=matColSize[0];
    int result=0;
    for(int i=0; i<r; i++){
        result += mat[i][i] + mat[i][r-1-i];
    }
    if(r%2==1)
        result -= mat[r/2][r/2];
    return result;
}
```

### 3、[最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)

```C
int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){
    int r=accountsSize;
    int max=0;
    for(int i=0; i<r; i++){
        int all=0;
        for(int j=0; j<accountsColSize[i]; j++)
            all += accounts[i][j];
        if(max < all)
            max=all;
    }
    return max;
}
```

### 4、[托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)

```C
bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){
    int r=matrixSize, l=matrixColSize[0];
    int i,j;
    for(i=0; i<l-1; i++)
        for(int tmp=i; tmp<l-1; tmp++)
            if(tmp-i<r-1)
                if(matrix[tmp-i][tmp] != matrix[tmp-i+1][tmp+1])
                    return false;
    for(j=1; j<r-1; j++)
        for(int tmp=j; tmp<r-1; tmp++)
            if(tmp-j<l-1)
                if(matrix[tmp][tmp-j] != matrix[tmp+1][tmp+1-j])
                    return false;
    return true;
}
```

### 5、[矩阵中的幸运数](https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int min(int a, int b){
    return a<b ? a : b;
}
int max(int a, int b){
    return a>b ? a : b;
}

int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    int r=matrixSize, c=matrixColSize[0];
    int *ret=(int *)malloc(sizeof(int)*r*c);
    *returnSize=2;
    int rmin[r], cmax[c];
    
    
    for(int i=0; i<r; i++){
        rmin[i]=matrix[i][0];
        for(int j=1; j<c; j++){
            rmin[i]=min(rmin[i], matrix[i][j]);
        }
    }
    for(int j=0; j<c; j++){
        cmax[j]=matrix[0][j];
        for(int i=1; i<r; i++){
            cmax[j]=max(cmax[j], matrix[i][j]);
        }
    }
    *returnSize = 0;
    for(int j=0; j<c; j++){
        for(int i=0; i<r; i++){
            if(rmin[i]==cmax[j])
                ret[ (*returnSize)++ ] = rmin[i]; 
        }
    }
    return ret;
}
```

### 6、[二进制矩阵中的特殊位置](https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/)

```C
int numSpecial(int** mat, int matSize, int* matColSize){
    int r=matSize, c=matColSize[0], ans=0;
    
    int rdata[r], cdata[c];
    for(int i=0; i<r; i++){		//筛选所有只包含一个1的行，并把1出现的位置加5后存在rdata[i]中
        rdata[i]=0;
        for(int j=0; j<c; j++)
            if(mat[i][j]==1)
                if(rdata[i]==0)
                    rdata[i]=j+5;
                else{
                    rdata[i]=0;
                    break;
                } 
    }
    
    for(int i=0; i<r; i++){
        int sum=0;
        if(rdata[i]){	//判断符合条件的行，是否满足所在列没有其他1的条件
            for(int j=0; j<r; j++)
                sum += mat[j][rdata[i]-5];
            if(sum != 1)
                sum = 0;
        }
        ans += sum;
    }
    return ans;        
}
```

### 7、[岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

```C
int islandPerimeter(int** grid, int gridSize, int* gridColSize){
    int r=gridSize+2, c=gridColSize[0]+2;

    int ** new=(int **)malloc(sizeof(int *) * r);
    for(int i=0; i<r; i++)
        *(new+i) = malloc(sizeof(int) * c);
    int i=0, j=0, ans=0;

    while(i<r){
        new[i][0]=0;
        new[i][c-1]=0;
        i++;
    }
    i=0;
    while(i<c){
        new[0][i]=0;
        new[r-1][i]=0;
        i++;
    }
    for( i=0; i<r-2; i++)
        for( j =0; j<c-2; j++)
            new[i+1][j+1]=grid[i][j];

    for(i=1; i < r-1; i++){
        for( j=1; j<c-1; j++){
            if(new[i][j])
                ans =ans + 4-(new[i-1][j] + new[i+1][j] + new[i][j-1] + new[i][j+1]);
        }
    }
    return ans;
}
```

# 2022.03.13

## leetcode刷题——08——二级指针



### LeetCode题目中二级指针的含义

```C
int** func(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
}
```

| 参数                | 变量类型 | 含义                                                         |
| ------------------- | -------- | ------------------------------------------------------------ |
| matrix              | 二级指针 | 传入的矩阵首地址                                             |
| matrixSize          | 普通变量 | 传入的矩阵的行数                                             |
| matrixColSize     | 一级指针 | 传入矩阵每行的列数（注意是每行，所以是数组）                 |
| returnSize        | 一级指针 | 传出矩阵的行数，由于需要作为参数返回，所以用指针取地址       |
| returnColumnSizes | 二级指针 | 传出矩阵的每行的列数，由于需要作为数组参数返回，所以用二级指针 |

### 二维数组的内存申请模板

```C
int **myMalloc(int r, int c, int* returnSize, int** returnColumnSizes) {
    int i;
    int **ret = (int **)malloc( sizeof(int *) * r );        // (1)
    *returnColumnSizes = (int *)malloc( sizeof(int) * r );  // (2)
    *returnSize = r;                                        // (3)
    for(i = 0; i < r; ++i) {
        ret[i] = (int *)malloc( sizeof(int) * c );          // (4)
        (*returnColumnSizes)[i] = c;                        // (5)
    }    
    return ret;
}
/*
(1) 申请一个矩阵（二维数组）的内存，行数为 r，首地址为ret，二维数组的类型为int **，二维数组中每个元素的类型为一级指针，即int *，对应sizeof(int *)这个表达式；
(2) 为这个矩阵的列申请一个数组来记录它每一行的列数，所以这个列数组的长度应该是行数r，由于需要作为参数返回给调用方，所以这里调用了一次解引用；
(3) *returnSize是需要返回的矩阵的行数，调用者不知道这个功能返回的矩阵有多少行，需要实现者告诉他，同样调用一次解引用；
(4) 申请矩阵每一行的内存空间，每一行的长度为c，即列数；
(5) 每一行的列数长度需要作为返回值返回，所以需要先解引用再索引到行号，即给(*returnColumnSizes)进行赋值；
*/
```

### 1、[翻转图像](https://leetcode-cn.com/problems/flipping-an-image/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int* returnSize, int** returnColumnSizes){
    int i;
    int ** ret = (int **)malloc(sizeof(int *) * r);
    *returnColumnSizes = (int *)malloc(sizeof(int) *r);
    *returnSize = r;
     for(i=0; i<r; i++){
         ret[i]=(int *)malloc(sizeof(int) * c);
         (*returnColumnSizes)[i] = c;
     }
     return ret;
}

int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){
    int i,j;
    int r=imageSize, c=imageColSize[0];
    int ** ret=myMalloc(r, c, returnSize, returnColumnSizes);
    for(i=0; i<r; i++)
        for(j=0; j<c; j++)
            ret[i][j]=1-image[i][c-1-j];
    return ret;
}
```

### 2、[转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int *returnSize, int ** returnColumnSizes){
    int i;
    int ** ret=(int **)malloc(sizeof(int *)*r);
    *returnColumnSizes = (int *)malloc(sizeof(int)*r);
    *returnSize=r;

    for(i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int) * c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
    int r=matrixSize, c=matrixColSize[0];
    int **ret=myMalloc(c, r, returnSize, returnColumnSizes);
    for(int i=0; i<c; i++)
        for(int j=0; j<r; j++){
            ret[i][j]=matrix[j][i];
        }
    return ret;
}
```

### 3、[重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** mymalloc(int r, int c, int *returnSize, int ** returnColumnSizes){
    *returnSize = r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int)*c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){
    int m = matSize, n = matColSize[0], id=0;
    int ** ret=mymalloc(r, c, returnSize, returnColumnSizes);
    if(n*m != r*c){
        *returnSize = m;
        for(int i=0; i<m; i++)
            (*returnColumnSizes)[i]=n;
        return mat;
    }


    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id=i*c+j;
            ret[i][j]=mat[id/n][id%n];
        }
    return ret;
}
```

### 4、[将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;    
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int **ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int)*c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){
    int ** ret;
    if(n*m != originalSize){
        *returnSize=0;
        return ret;
    }
    ret=myMalloc(m, n, returnSize, returnColumnSizes);
    for(int i=0; i<m; i++)
        for(int j=0; j<n; j++)
            ret[i][j]=original[i*n+j];
    return ret;
}
```

### 5、[二维网格迁移](https://leetcode-cn.com/problems/shift-2d-grid/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=gridSize, c=gridColSize[0], id;
    int **ret = myMalloc(r, c, returnSize, returnColumnSizes);
    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id= i*c+j-k;
            while(id<0)
                id += r*c;
            ret[i][j]=grid[id/c][id%c];
        }
    return ret;
}

/*------------*/
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=gridSize, c=gridColSize[0], id;
    int **ret = myMalloc(r, c, returnSize, returnColumnSizes);
    k=k%(r*c);
    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id= i*c+j-k;
            if(id<0)
                id += (r*c);
            ret[i][j]=grid[id/c][id%c];
        }
    return ret;
}
```

### 6、[图片平滑器](https://leetcode-cn.com/problems/image-smoother/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int *)*c);
    }
    return ret;
}
int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){
    int r=imgSize, c=imgColSize[0];
    int ** ret=myMalloc(r, c, returnSize, returnColumnSizes);
    
    if(c>1 && r>1){
        for(int i; i<r; i++)
            for(int j=0; j<c; j++){
                //第一行
                if(i==0 && j==0)
                    ret[0][0]=(img[0][0]+img[0][1]+img[1][0]+img[1][1])/4;
                else if(i==0 && j==c-1)
                    ret[0][c-1]=(img[0][c-2]+img[0][c-1]+img[1][c-2]+img[1][c-1])/4;
                else if(i==0)
                    ret[0][j]=(img[0][j-1]+img[0][j]+img[0][j+1]+img[1][j-1]+img[1][j]+img[1][j+1])/6;
                //第一列
                else if(i<r-1 && j==0)
                    ret[i][0]=(img[i-1][0]+img[i][0]+img[i+1][0]+img[i-1][1]+img[i][1]+img[i+1][1])/6;
                //中间
                else if(i<r-1 && j>0 && j<c-1)
                    ret[i][j]=(img[i-1][j-1]+img[i-1][j]+img[i-1][j+1]+img[i+1][j-1]+img[i+1][j]+img[i+1][j+1]+img[i][j-1]+img[i][j]+img[i][j+1])/9;
                //最后一列
                else if(i<r-1 && j == c-1)
                    ret[i][c-1]=(img[i-1][c-1]+img[i][c-1]+img[i+1][c-1]+img[i-1][c-2]+img[i][c-2]+img[i+1][c-2])/6;
                //最后一行
                else if(i==r-1){
                    if(j==0)
                        ret[r-1][0]=(img[r-2][0]+img[r-2][1]+img[r-1][0]+img[r-1][1])/4;
                    else if(j == c-1)
                        ret[r-1][c-1]=(img[r-2][c-2]+img[r-2][c-1]+img[r-1][c-2]+img[r-1][c-1])/4;
                    else    
                        ret[r-1][j]=(img[r-1][j-1]+img[r-1][j]+img[r-1][j+1]+img[r-2][j-1]+img[r-2][j]+img[r-2][j+1])/6;

                }
            }
    }else if(r==1 && c==1){
        ret[0][0]=img[0][0];
    }else if(r==1){
        int i=0;
        for(int j=0; j<c; j++){
            if(j==0)
                ret[i][j]=(img[i][j]+img[i][j+1])/2;
            else if(j<c-1)
                ret[i][j]=(img[i][j-1]+img[i][j]+img[i][j+1])/3;
            else
                ret[i][j]=(img[i][j]+img[i][j-1])/2;
        }
    }else if(c==1){
        int j=0;
        for(int i=0; i<r; i++){
            if(i==0)
                ret[i][j]=(img[i+1][j]+img[i][j])/2;
            else if(i<r-1)
                ret[i][j]=(img[i-1][j]+img[i+1][j]+img[i][j])/3;
            else
                ret[i][j]=(img[i-1][j]+img[i][j])/2;
        }
    }

    return ret;
}
```

### 7、[矩阵区域和](https://leetcode-cn.com/problems/matrix-block-sum/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret = (int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int the_sum(int** mat, int r, int c, int k, int i, int j){
    int sum=0, left=i-k, right=i+k, up=j-k, down=j+k;
    for(int p=0; p<r; p++)
        for(int q=0; q<c; q++)
            if(left<=p && p<=right && up<=q && q<=down)
                sum+=mat[p][q];
    return sum;
}
int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=matSize, c=matColSize[0];
    int **ret=myMalloc(r, c, returnSize, returnColumnSizes);
    for(int i=0; i<r; i++){
        for(int j=0; j<c; j++){
            ret[i][j]=the_sum(mat, r, c, k ,i ,j);
        }
    }
    return ret;
}
```

### 8、[距离顺序排列矩阵单元格](https://leetcode-cn.com/problems/matrix-cells-in-distance-order/)

```C
int r0, c0;

int cmp(void* _a, void* _b) {
    int *a = *(int**)_a, *b = *(int**)_b;
    return fabs(a[0] - r0) + fabs(a[1] - c0) - fabs(b[0] - r0) - fabs(b[1] - c0);
}

int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes) {
    r0 = rCenter, c0 = cCenter;
    //分配空间
    int** ret = malloc(sizeof(int*) * rows * cols);
    *returnColumnSizes = malloc(sizeof(int) * rows * cols);
    for (int i = 0; i < rows * cols; i++) {
        (*returnColumnSizes)[i] = 2;
        ret[i] = malloc(sizeof(int) * 2);
    }

    *returnSize = 0;
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            ret[*returnSize][0] = i;
            ret[*returnSize][1] = j;
            (*returnSize)++;
        }
    }
    qsort(ret, rows * cols, sizeof(int*), cmp);
    return ret;
}
```




# 2022.03.01

## 上传GitHub，git push失败

失败提示： `gnutls_handshake() failed: The TLS connection was non-properly terminated.`

1、重置代理
```shell
git config --global  --unset https.https://github.com.proxy 
git config --global  --unset http.https://github.com.proxy 
```

2、重新设置账户
```shell
git config --global user.name "xxx"
git config --global user.email "xxxx"
```

3、重新申请token

4、git push时输入新的token

## U盘被分区后，重新格式化成一个盘

1、Win + R，输入CMD，打开Windows终端

2、输入 `diskpart` 指令，弹出新窗口

3、输入 `list disk` 列出所有磁盘

4、输入 `select disk 磁盘序号` 选择磁盘

5、输入 `clean` 清除分区，然后就可以在磁盘管理器里面看到一块未格式化的磁盘

![Image](https://raw.githubusercontent.com/simoonp/picture/main/log/disk.png)


## git删除远程文件
```shell
git rm --cached 文件名
```

## 微星主板刷BIOS

1、在微星官网下载BIOS文件，将压缩包内的 `.2E0` 文件重命名为 `MSI.ROM` 复制到FAT32格式U盘的根目录下

(注：部分劣质U盘，主板可能无法识别)

2、将主板插上24Pin主板供电和8Pin供电，电源上电，主机开关不用开启

3、将U盘插到主板带有BIOS或Flash字样的USB口（没有标注的查阅说明书或询问客服），长按BIOS刷写按钮3秒然后松开，当红灯开始闪烁说明正在搜索BIOS文件，红灯快速闪烁说明正在写入BIOS，指示灯熄灭表示写入完毕(也可能写入完毕后指示灯常亮)。

## 京东脚本库
```shell
1、
ql repo https://github.com/zero205/JD_tencent_scf.git "jd_|jx_|jdCookie" "backUp|icon" "^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql" "main"
2、
ql repo https://github.com/atyvcn/jd_scripts.git "jd_|jx_|ty_|CheckRpeat" "activity|backUp|icon" "^jd[^_]|^JD|USER|utils|function|^sign|sendNotify"
3、
ql repo https://github.com/smiek2221/scripts.git "jd_|gua_" "" "ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js"

4、
ql repo https://github.com/he1pu/JDHelp.git "jd_|jx_|getJDCookie" "activity|backUp|jd_delCoupon" "^jd[^_]|USER"
```

## leetcode刷题——01——函数

### 1、[两整数求和](https://leetcode-cn.com/problems/sum-of-two-integers/)，[面试题 17.01. 不用加号的加法](https://leetcode-cn.com/problems/add-without-plus-lcci/)，[剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

```C
int add(int a, int b){
    if(b == 0)
        return a;
    return add(a^b,(a&(b&0xffffffff))<<1);
    // 为啥b加上0xffffffff后就不报错了？
    // LC C/C++不支持负值左移，需要强制转换为无符号数
    // return add(a^b,(unsigned int)(a&(b))<<1);
}
```
### 2、[递归乘法](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

```C
int multiply(int A, int B){
    //return A*B;

    // if(B==0)
    //     return 0;
    // int temp_a=A;
    // if(B>0){
    //     while(B>1){
    //         A += temp_a;
    //         B--;
    //     }
    // }else if(B<0){
    //     while(B<-1){
    //         A += temp_a;
    //         B++;
    //     }
    // }
    // return A;
       
    if (B==0)
        return 0;
    if (B>1)
        return A + multiply(A, B-1);
    else if(B<-1)
        return A + multiply(A, B+1);
    return A;

}
```

### 3、[Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

```C
double myPow(double x, int n){
    double res = 1;
    int i = n;
    while(i){
        if(i%2)
            res *= x;
 
        x *= x;

        i /= 2;
    }

    // double res = 1.0;
    // for(int i = n; i != 0; i /= 2){
    //     if(i % 2 != 0){
    //         res *= x;
    //     }
    //     x *= x;
    // }

    return  n < 0 ? 1 / res : res;

}
```

### 4、[x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

```C
int mySqrt(int x){
    // return sqrt(x);

    // int i=1, tmp = 1;
    // while(tmp<46340 && i<x){
    //     tmp++;
    //     i = tmp*tmp;
    // }
    // if(i > x)
    //     tmp--;
    // return tmp;

    // 牛顿迭代法
    if(x == 1)
        return 1;
    int min = 0;
    int max = x;
    while(max-min>1)
    {
        int m = (max+min)/2;
        if(x/m<m)
            max = m;
        else
            min = m;
    }
    return min;
}
```

### 5、[面试题 16.07. 最大数值](https://leetcode-cn.com/problems/maximum-lcci/)

```C
int maximum(int a, int b){
// a < b:
// 1 + (a - b) >> 31 == 0
// a > b:
// 1 + (a - b) >> 31 == 1

    long c = a, d = b;
    int k = 1 + ((c - d) >> 63);
    return k * a + (!k) * b;
}
```

### 6、[2119. 反转两次的数字](https://leetcode-cn.com/problems/a-number-after-a-double-reversal/)

```C
bool isSameAfterReversals(int num){
    if(num==0 || num%10)
        return true;
    return false;
}
```



# 2022.03.03

## 刷机 Redmi AC2100

### 需要的固件

`ac2100 breed` breed-mt7621-xiaomi-r3g.bin

`AC2100 2.0.7 旧固件` miwifi_rm2100_firmware_d6234_2.0.7.bin

`OpenWRT临时固件` openwrt-21.02.2-ramips-mt7621-xiaomi_redmi-router-ac2100-initramfs-kernel.bin

`Openwrt系统固件` openwrt-ramips-mt7621-xiaomi_redmi-router-ac2100-squashfs-sysupgrade.bin

scp -r breed-mt7621-xiaomi-r3g.bin root@192.168.31.1:/tmp/

### 1、系统降级

完成路由器的基本设置(设置密码)，登录路由器管理界面，在页面右上角，系统升级的位置，选择手动升级，选择下载的`miwifi_rm2100_firmware_d6234_2.0.7.bin`旧系统固件，完成后等待系统自动重启

![Snipaste_2022-03-03_17-10-30](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-10-30.png)

### 2、开启SSH

重新完成路由器基本设置，登录路由器后台，看浏览器地址连的url地址，记录stok后面的一串字符

```C
// ip可能会不一样，<stok>是一长串字符每次登录后都不一样
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/web/home#router
```

![Snipaste_2022-03-03_14-37-53](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-37-53.png)

使用下述代码进行注入，将`<stok>`替换为浏览器地址栏显示的值后再输入进地址栏

```c
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B
```

![Snipaste_2022-03-03_14-39-10](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-39-10.png)

输入地址，回车后，浏览器会显示`{"code":0}`

![Snipaste_2022-03-03_14-42-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-42-15.png)

退出再刷新浏览器重新进入管理界面，此时`<stok>`会发生变化，再通过下述代码修改root密码：

![Snipaste_2022-03-03_14-43-09](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-43-09.png)

```C
http://192.168.31.1/cgi-bin/luci/;stok=<STOK>/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B
```

![Snipaste_2022-03-03_14-44-49](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-44-49.png)

此时能够使用ssh登录进路由器，账号为：root 密码为：admin

使用CMD控制台ssh进入路由器系统(路由器IP：192.168.31.1)

![Snipaste_2022-03-03_14-46-09](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-46-09.png)

### 3、刷入breed

新开一个CMD窗口，通过scp指令远程上传文件到路由器`/tmp/`文件夹

![Snipaste_2022-03-03_14-54-27](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_14-54-27.png)

备份路由器原来的分区文件

![Snipaste_2022-03-03_15-20-03](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-20-03.png)

```shell
# 在路由器终端输入
dd if=/dev/mtd0 of=/tmp/all.bin
dd if=/dev/mtd1 of=/tmp/bootloader.bin
dd if=/dev/mtd4 of=/tmp/eeprom.bin
```

将备份的文件下载到本地

```shell
# 在Windows的CMD控制台输入：
scp root@192.168.31.1:/tmp/all.bin .
scp root@192.168.31.1:/tmp/bootloader.bin .
scp root@192.168.31.1:/tmp/eeprom.bin .
```

![Snipaste_2022-03-03_17-19-48](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-19-48.png)

![Snipaste_2022-03-03_15-21-32](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-21-32.png)

在路由器终端执行：

```she
mtd -r write /tmp/breed-mt7621-xiaomi-r3g.bin Bootloader
```

![Snipaste_2022-03-03_15-23-03](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-23-03.png)

### 4、刷入临时系统

如果电脑重新获取到IP后说明刷写完成并且breed引导了官方固件，断电。按住reset键（背面圆孔，用取卡针插进去）后插电等待system的蓝灯闪烁后松开reset键。

用浏览器访问`192.168.1.1`进入breed恢复界面，更改环境变量，新增字段"xiaomi.r3g.bootfw", 值设置为 2,然后保存。

![Snipaste_2022-03-03_15-26-44](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-26-44.png)

![Snipaste_2022-03-03_15-28-53](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_15-28-53.png)



点击固件更新，上传自己的固件(选择 `openwrt-21.02.2-ramips-mt7621-xiaomi_redmi-router-ac2100-initramfs-kernel.bin`)，点击`上传`

![Snipaste_2022-03-03_17-26-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-26-15.png)

![Snipaste_2022-03-03_17-29-15](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-29-15.png)

![Snipaste_2022-03-03_17-29-35](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_17-29-35.png)

### 5、刷入Openwrt

重启完成之后，打开192.168.1.1，进入临时系统，用户名是root，没有密码。选择要输入的固件(`openwrt-ramips-mt7621-xiaomi_redmi-router-ac2100-squashfs-sysupgrade.bin`)

![Snipaste_2022-03-03_16-08-46](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-08-46.png)

![Snipaste_2022-03-03_16-10-20](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-10-20.png)

不要勾选 `Keep settings and retain the current configuration`

![Snipaste_2022-03-03_16-15-29](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-15-29.png)

![Snipaste_2022-03-03_16-15-38](https://raw.githubusercontent.com/simoonp/picture/main/Redmi_AC2100/Snipaste_2022-03-03_16-15-38.png)

上传后等待路由器重启

## leetcode刷题——02——循环

### 1、[剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

```C
int sumNums(int n){
    /*
    int sum=0;
    while(n){
        sum += n;
        n--;
    }
    return sum;
*/
    if(n%2==0)
        return n/2*(n+1);
    else 
        return (n+1)/2*n;
}
```

### 2、[2 的幂](https://leetcode-cn.com/problems/power-of-two/)

```C
bool isPowerOfTwo(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 1;
    while(tmp < n && i <=30 ){
        tmp *= 2;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
    
	// return (n>0)&&(n &(n-1)) == 0;		//内存消耗小
}
```

### 3、[3 的幂](https://leetcode-cn.com/problems/power-of-three/)

```C
bool isPowerOfThree(int n){
    // if (n==0)
    //     return false;
    // if (n==1)
    //     return true;
    // int tmp =  1, i = 0;
    // while(tmp < n && i <=18 ){
    //     tmp *= 3;
    //     i++;
    //     if(tmp == n)
    //         return true;
    // }
    // return false;
    
    while(n && n%3==0)
        n /= 3;
    return n==1;
}
```

### 4、[4的幂](https://leetcode-cn.com/problems/power-of-four/)

```C
bool isPowerOfFour(int n){
    if (n==0)
        return false;
    if (n==1)
        return true;
    int tmp =  1, i = 0;
    while(tmp < n && i <=14 ){
        tmp *= 4;
        i++;
        if(tmp == n)
            return true;
    }
    return false;
    // return ((n>0) && (n&(n-1))==0) && (n%3==1);
}
```

### 5、[n 的第 k 个因子](https://leetcode-cn.com/problems/the-kth-factor-of-n/)

```C
int kthFactor(int n, int k){
    // int i = 1, num=0;
    // for(;i<=n;i++){
    //     if(n%i==0){
    //         num++;
    //     }
    //     if(num==k){
    //         return i;
    //     }
    // }
    // return -1;

    int i = 1;
    for(; i*i < n; i ++) {
        if((n%i == 0) && (--k == 0)) {
            return i;
        }
    }    
    if(i * i != n) {
        i --;
    }
    // from sqrt(n) again
    for(; i >= 1; i --) {
        if((n%i == 0) && (--k==0)) {
            return n/i;
        }            
    }
    return -1;
}
```

### 6、[有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

```C
bool isPerfectSquare(int num){
    // for(int i=1;num/i>=i;i++)
    //     if(num == i*i)
    //         return true;
    // return false;
    double x0 = num;
    while (true) {
        double x1 = (x0 + num / x0) / 2;
        if (x0 - x1 < 1e-6) {
            break;
        }
        x0 = x1;
    }
    int x = (int) x0;
    return x * x == num;
}
```

## VS Code连接本地WSL出现`VS Code Server for WSL closed unexpectedly.`错误

![vs_code_wsl.png](https://raw.githubusercontent.com/simoonp/picture/main/log/vs_code_wsl.png)

`临时解决方法`：

```shell
# 通过其他方式进入wsl，修改  ~/.vscode-server/bin/*******************/ 文件夹下的server.sh文件
# 在最后一行的 "$ROOT/node" ${INSPECT:-} "$ROOT/out/server-main.js" --compatibility=1.63 "$@" 中加入
# -accept-server-license-terms (这将自动接受条款，直到 MS 对其进行修补)，修改后为：
# "$ROOT/node" ${INSPECT:-} "$ROOT/out/server-main.js" --compatibility=1.63 --accept-server-license-terms "$@"
```



# 2022.03.04

## leetcode刷题——03——一维数组

### 1、[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```C
int search(int* nums, int numsSize, int target){
    // int len = numsSize;
    // int left = 0, right = len-1;
    // while(left <= right){
    //     int mid = (left + right) / 2;
    //     if(nums[mid] == target)
    //         return mid;
    //     else if(nums[mid] < nums[right]){
    //         if(nums[mid] < target && target <= nums[right])
    //             left = mid+1;
    //         else
    //             right = mid-1;
    //     }
    //     else{
    //         if(nums[left] <= target && target < nums[mid])
    //             right = mid-1;
    //         else
    //             left = mid+1;
    //     }
    // }
    // return -1;

    int left = 0, right = numsSize-1;
    int mid;
    while(left <= right){
        mid = (left+right)/2;
        if(nums[mid]==target){
            return mid;
        }
        if(nums[mid]<nums[right]){
            if(nums[mid]<target && target<=nums[right])
                left = mid+1;
            else
                right = mid-1;
        }else{
            if(nums[left]<=target && target<nums[mid])
                right = mid-1;
            else
                left = mid+1;
        }
    }
    return -1;
}
```

### 2、[搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

```C
bool search(int* nums, int numsSize, int target){
    // for(int i=0; i< numsSize; i++)
    //     if(nums[i]==target)
    //         return true;
    // return false;

    if (numsSize == 0) {
        return false;
    }
    if (numsSize == 1) {
        return nums[0] == target;
    }
    int l = 0, r = numsSize - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (nums[mid] == target) {
            return true;
        }
        if (nums[l] == nums[mid] && nums[mid] == nums[r]) {
            ++l;
            --r;
        } else if (nums[l] <= nums[mid]) {
            if (nums[l] <= target && target < nums[mid]) {
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[numsSize - 1]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
    }
    return false;
}
```

### 3、[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

```C
int findMin(int* nums, int numsSize){
    int low = 0;
    int high = numsSize - 1;
    while (low < high) {
        int pivot = low + (high - low) / 2;
        if (nums[pivot] < nums[high]) {
            high = pivot;
        } else {
            low = pivot + 1;
        }
    }
    return nums[low];
}
```

### 4、[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```C
int climbStairs(int n){
    // if (n==1)
    //     return 1;
    // if (n==2)
    //     return 2;
    // int i=1, j =2,sum;
    // for(int tmp=3; tmp<=n ;tmp++){
    //     sum = i+j;
    //     i=j;
    //     j=sum;
    // }
    // return j;
    
    // int p = 0, q = 0, r = 1;
    // for (int i = 1; i <= n; ++i) {
    //     p = q;
    //     q = r;
    //     r = p + q;
    // }
    // return r;
    
    // 通项公式
    double sqrt5 = sqrt(5);
    double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);
    return (int) round(fibn / sqrt5);
}
```

### 5、[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```C
int fib(int n){
    if(n){
        int p = 0, q = 0, r = 1;
        for (int i = 2; i <= n; ++i) {
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
    return 0;
}
```

### 6、[第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

```C
int tribonacci(int n){
    if(n){
        int p = 0, q = 1, r = 1, s = 1;
        for (int i = 3; i <= n; ++i) {
            s=p+q+r;
            p = q;
            q = r;
            r = s;
        }
        return s;
    }
    return 0;
}
```

### 7、[差的绝对值为 K 的数对数目](https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/)

```C
int countKDifference(int* nums, int numsSize, int k){
    int i,j,num=0;
    for(i=0; i<numsSize; i++){
        for(j=i+1; j<numsSize; j++){
            if(abs(nums[i]-nums[j])==k)
                num++;
        }
    }
    return num;
}
```

### 8、[ 猜数字](https://leetcode-cn.com/problems/guess-numbers/)

```C
int game(int* guess, int guessSize, int* answer, int answerSize){
    int num=0;
    for(int i=0; i<guessSize; i++){
        if(guess[i]==answer[i])
           num++; 
    }
    return num;
}
```

### 9、[拿硬币](https://leetcode-cn.com/problems/na-ying-bi/)

```C
int minCount(int* coins, int coinsSize){
    int sum=0;
    for(int i=0; i<coinsSize; i++)
        // if(coins[i]%2==)
            sum += (coins[i]+1)/2;
    return sum;
}
```

### 10、[剑指 Offer II 069. 山峰数组的顶部](https://leetcode-cn.com/problems/B1IidL/)

```C
int peakIndexInMountainArray(int* arr, int arrSize){
    int i;
    for( i=1; i<arrSize-1; i++)
        if(arr[i]>arr[i-1] && arr[i]>arr[i+1])
            break;
    return i;
}
```

# 2022.03.05

## leetcode刷题——04——指针

### [基础知识点](http://c.biancheng.net/c/pointer/)

1、定义方法：`变量类型` `*变量名`

```C
int *pa;
```

2、`*p = &普通变量名`(指针刚定义的时候可以这么写，定义完后再赋值就要`*p = 普通变量名`)，`*p = 数组名`，

使用运算符` & `求某个变量的地址，使用`*`运算符对指针取值。

```C
// 在使用已定义好的指针变量时，在变量名前面不能加 *。例如：
int *p,a;
*p=&a; //错误，指针变量是p而不是*p

int a,*p=&a; //正确 => int a; int* p=&a;
// 该语句貌似把 &a 赋给了 *p，而实际上 p 前的 * 仅是定义指针变量 p 的标识，仍然是把 &a 赋给了 p，故是正确的赋值语句。
```

```C
// 指针变量中只能保存该基类型变量的地址
int a,b,*pa,*pb;
char *pc,c;

pa=&a;	// 正确。pa基类型为int，a为int型变量，类型一致
pb=&c;	// 错误。pb基类型为int，c为char型变量，类型不一致
pc=&c;	// 正确。pc基类型为char,c为char型变量，类型一致
*pa=&a;	// 错误。指针变量是pa而非*pa
```

```C
// 指针变量的值可以改变，也即可以改变指针变量的指向
char c1,*pc,c2;//定义了字符变量c1、c2和字符指针变量pc
pc=&c1; //pc指向c1
pc=&c2; //pc不再指向c1，而指向c2
```

```C
// 同类型的指针变量可以相互赋值
int a,*p1,*p2,b;//定义了两个整型变量a,b;两个整型指针变量为p1,p2
float *pf;

p1=&a; // 地址箱p1中保存a的地址，即p1指向a
p2=p1; // p2也指向a，即p1和p2均指向a

pf=p1； // 错误。p1,pf虽然都是指针变量，但类型不同，不能赋值
pf=&b;  // 错误。指针变量pf的基类型为float，b类型为int,不相同

int a=3,*pa=&a; //pa保存变量a的地址，即指向a
char c='d',*pc=&c; //pc保存变量c的地址，即指向c
```

3、指针变量的引用

`直接访问`：知道内存空间的名字，可通过名字访问该空间，变量即代表有名字的内存单元，通过变量名操作变量，也就是通过名字直接访问该变量对应的内存单元。

`间接访问`：知道内存空间的地址，可以通过该地址间接访问该空间，对内存空间的访问操作一般指的是存、取操作，即向内存空间中存入数据和从内存空间中读取数据。

使用间接访问符（取内容访问符）`*`来访问指针所指向的空间

```C
int *p,a=3; //p中保存变量a对应内存单元的地址
p=&a;
printf("a=%d\n",a); //通过名字，直接访问变量a空间（读取）
printf("a=%d\n",*p); //通过地址，间接访问变量a空间（读取）
*p=6;//等价于a=6;间接访问a对应空间（存）
```

4、野指针

`野指针`：没有合法指向的指针，“野”指针随机指向一块空间，该空间中存储的可能是其他程序的数据甚至是系统数据，故不能对“野”指针所指向的空间进行存取操作，否则轻者会引起程序崩溃，严重的可能导致整个系统崩溃。

```C
int *pi,a; //pi未初始化，无合法指向，为“野”指针

*pi=3; //运行时错误！不能对”野”指针指向的空间做存入操作。该语句试图把 3 存入“野”指针pi所指的随机空间中，会产生运行时错误。
a=*pi; //运行时错误！不能对”野”指针指向的空间取操作。该语句试图从“野”指针pi所指的空间中取出数据，然后赋给变量a同样会产生运行时错误。

// 正确用法：
pi=&a;//让pi有合法的指向，pi指向a变量对应的空间
*pi=3;//把3间接存入pi所指向的变量a对应的空间
```

### 1、[重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* shuffle(int* nums, int numsSize, int n, int* returnSize){
    int i;
    int *ret=(int *)malloc(sizeof(int) * numsSize);
    for(i=0;i<numsSize;i++)
        if(i%2)
            ret[i]=nums[n+i/2];
        else
            ret[i]=nums[(i+1)/2];
    *returnSize = numsSize;
    return ret;
}
```

# 2022.03.06

### 2、[数组串联](https://leetcode-cn.com/problems/concatenation-of-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* getConcatenation(int* nums, int numsSize, int* returnSize){
    // int i=0;
    // int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    // for(;i<numsSize;i++){
    //     *(ret+numsSize)=*nums;
    //     *ret++=*nums++;
    // }
    // *returnSize=2*numsSize;
    // return ret-numsSize;


    int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    int *tmp=ret;
    while(ret<tmp+numsSize){
        *(ret+numsSize)=*nums;
        *ret++=*nums++;
    }
    *returnSize=2*numsSize;
    return ret-numsSize;

    // int i=0;
    // int * ret = (int *)malloc(sizeof(int)*2*numsSize);
    // for(;i<numsSize;i++){
    //     ret[i+numsSize]=ret[i]=nums[i];
    // }

    // *returnSize=2*numsSize;
    // return ret;
}
```

### 3、[基于排列构建数组](https://leetcode-cn.com/problems/build-array-from-permutation/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* buildArray(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)(malloc)(sizeof(int)*numsSize);
    // int *tmp=ret+numsSize;
    int i=0;
    // while(i<numsSize)
    //     *ret++=nums[nums[i++]];
    while(i<numsSize){
        ret[i]=nums[nums[i]];
        i++;
    }
    *returnSize=numsSize;
    return ret;
}
```

### 4、[一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* runningSum(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0;i<numsSize;i++){
        ret[i]=nums[i];
        if(i)
            ret[i]+=ret[i-1];
    }
    *returnSize=numsSize;
    return ret;
    
    for(int i=1; i<numsSize; i++)
        nums[i] += nums[i-1];

    *returnSize=numsSize;
    return nums;
}
```

### 5、[左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```C
char* reverseLeftWords(char* s, int k){
    int i;
    int n = strlen(s);
    char *ret = (char *)malloc( (n + 1) * sizeof(char) );    // (1)
    for(i = 0; i < n; ++i) {
        ret[i] = s[(i + k) % n];                             // (2)
    }
    ret[n] = '\0';                                           // (3)
    return ret;
}
```

### 6、[IP 地址无效化](https://leetcode-cn.com/problems/defanging-an-ip-address/)

```C
char * defangIPaddr(char * address){
    char *ret=(char *)malloc(sizeof(char)*23);
    int i=0;
    do{
        i +=1;
        if(*address == '.'){
            i+=2;
            *ret++ = '[';
            *ret++ = '.';
            *ret++ = ']';
        }else
            *ret++=*address;
    }while(*address++ != '\0');
    *ret='\0';
    return ret-i;
}
```

### 7、[ 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```C
char* replaceSpace(char* s){
    char *ret=(char *)malloc(sizeof(char)*300001);
    int i=0;
    do{
        if(*s == ' '){
            *ret++ = '%%';
            *ret++ = '2';
            *ret++ = '0';
            i+=3;
        }else{
            i++;
            *ret++=*s;
        }
    }while(*s++ );
    *ret = '\0';
    return ret-i;
}
```

### 8、[有多少小于当前数字的数字](https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    
    for(int i=0;i<numsSize;i++){
        int sum=0;
        for(int j=0; j<numsSize;j++)
            if(j!=i)
                if(nums[j]<nums[i])
                    sum++;
        ret[i]=sum;
    }
    *returnSize = numsSize;
    return ret;
}
```

### 9、[打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* printNumbers(int n, int* returnSize){
    int len=1;
    for(int i=0; i<n; i++)
        len *= 10;
    len--;
    int *ret = (int *)malloc(sizeof(int)*(len));
    for(int i=0; i<len; i++)
        ret[i]=i+1;
    *returnSize = len;
    return ret;
}
```

### 10、[按既定顺序创建目标数组](https://leetcode-cn.com/problems/create-target-array-in-the-given-order/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* createTargetArray(int* nums, int numsSize, int* index, int indexSize, int* returnSize){
    int *target=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0; i<numsSize; i++){
        for(int j=i; j>index[i]; j--)
            target[j]=target[j-1];
        target[index[i]]=nums[i];
    }
    *returnSize = numsSize;
    return target;
}
```

# 2022.03.07

## leetcode刷题——05——排序API

### 1、[排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

int cmp(const void*a, const void* b){
    return *(int *)a - *(int *)b;
}
int* sortArray(int* nums, int numsSize, int* returnSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    *returnSize = numsSize;
    return nums;
}
```

### 2、[多数元素](https://leetcode-cn.com/problems/majority-element/)

```C
int cmp(const void* a, const void* b){
    return (*(int *)a) - (*(int *)b);
}
int majorityElement(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums[numsSize/2];
}
```

### 3、[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

```C
int cmp(const void* a, const void* b){
    return (*(int *)a) - (*(int *)b);
}
int majorityElement(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums[numsSize/2];
}
```

### 4、[最大间距](https://leetcode-cn.com/problems/maximum-gap/)

```C
int cmp(const void* a, const void *b){
    return (*(int *)a) - (*(int *)b);
}
int maximumGap(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int max=0;
    for(int i=0; i<numsSize-1; i++){
        if(nums[i+1]-nums[i]>max){
            max = nums[i+1]-nums[i];
        }
    }
    return max;
}
```

### 5、[按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int Qua(int x){
    return x&1;
}
int cmp(const void *a, const void *b){
    return Qua(*(int *)a) - Qua(*(int *)b);
}
int* sortArrayByParity(int* nums, int numsSize, int* returnSize){
    int i;
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    for(i=0; i<numsSize; i++){
        ret[i]=nums[i];
    }
    qsort(ret, numsSize, sizeof(int), cmp);
    *returnSize = numsSize;
    return ret;
}
```

### 6、[最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

```C
int cmp(const void* a, const void* b){
    return *(int *)a - *(int *)b;
}

int min(int a, int b){
    return a<b ? a : b;
}
int findMinDifference(char ** timePoints, int timePointsSize){
    int *ret=(int *)malloc(sizeof(int)*timePointsSize);
    int a,b,i;
    int ans=1440;
    for( i=0; i<timePointsSize; i++){
        sscanf(timePoints[i], "%d:%d",&a, &b);
        ret[i]=a*60 + b;
    }

    qsort(ret, timePointsSize, sizeof(int), cmp);

    for( i=1; i<timePointsSize; i++){
        ans=min(ans, ret[i]-ret[i-1]);
    }
    ans=min(ans, 1440-ret[timePointsSize-1]+ret[0]);
    return ans;
}
```

### 7、[三角形的最大周长](https://leetcode-cn.com/problems/largest-perimeter-triangle/)

```C
int cmp(const void* a, const *b)
{
    return *(int *)a - *(int *)b;
}
int largestPerimeter(int* nums, int numsSize){
    // int len=0;
    qsort(nums, numsSize, sizeof(int), cmp);
    for(int i=numsSize-1; i>1; i--)
        if(nums[i]<(nums[i-1]+nums[i-2]))
            return nums[i]+nums[i-1]+nums[i-2];
    return 0;
}
```

### 8、[救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)

```C
int cmp(const void* a, const void* b){
    return *(int *)a - *(int *)b;
}
int numRescueBoats(int* people, int peopleSize, int limit){
    qsort(people,peopleSize,sizeof(int),cmp);
    int num=0;
    int i;
    int l=0,r=peopleSize-1;
    while(l<=r){
        if(l==r){
            num++;
            break;
        }else if(people[l]+people[r]>limit){
            num++;
            r--;
        }else{
            num++;
            l++;
            r--;
        }
    }
    return num;
}
```

# 2022.03.11

## leetcode刷题——06——贪心

### 1、[两个数对之间的最大乘积差](https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int maxProductDifference(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return nums[numsSize-1]*nums[numsSize-2] - nums[0]*nums[1];
}
```

### 3、[数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int arrayPairSum(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int ret = 0;
    for(int i=0; i<numsSize; ){
        ret += nums[i];
        i+=2;
    }
    return ret;
}
```

### 5、[摆动排序 II](https://leetcode-cn.com/problems/wiggle-sort-ii/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}
void wiggleSort(int* nums, int numsSize){
    int *ret = (int *)malloc(sizeof(int) * numsSize);
    for(int i=0; i<numsSize; i++)
        ret[i]=nums[i];
    qsort(ret, numsSize, sizeof(int), cmp);
    int r=numsSize-1;
    for(int i=1; i<numsSize; i+=2)
        nums[i] = ret[r--];
    for(int i=0; i<numsSize; i+=2)
        nums[i] = ret[r--]; 
}
```

### 6、[分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a-*(int *)b;
}
int findContentChildren(int* g, int gSize, int* s, int sSize){
    qsort(g, gSize, sizeof(int), cmp);
    qsort(s, sSize, sizeof(int), cmp);
    int ans=0;
    int j=sSize-1, i=gSize-1;
 
    while(i>=0 && j>=0)
        if(s[j]>=g[i]){
            j--;
            i--;
            ans++;
        }else{
            i--;
        }
    return ans;
}
```

### 7、[最少操作使数组递增](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-increasing/)

```C
int minOperations(int* nums, int numsSize){
    int i=0, ans=0, pre=nums[0]+1;
    for(i=1; i<numsSize; i++){
        if(pre < nums[i])
            pre = nums[i]+1;
        else{
            ans += pre - nums[i];
            pre++;
        }
    }
    return ans;
}
```

### 8、[使数组唯一的最小增量](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a-*(int *)b;
}
// int min(int a, int b){
//     return a<b ? a : b;
// }
// int minIncrementForUnique(int* nums, int numsSize){
//     int * ret=(int *)malloc(sizeof(int)*numsSize);
//     for(int i=0;i<numsSize;i++)
//         ret[i]=nums[i];
//     qsort(ret, numsSize, sizeof(int), cmp);
//     int taken=0, ans=0;
//     for(int i=1; i<numsSize; i++){
//         if(ret[i-1]==ret[i]){
//             taken++;
//             ans = ans-ret[i];
//         }else{
//             int give=min(taken, ret[i]-ret[i-1]-1);
//             ans += give*(give+1)/2+give*ret[i-1];
//             taken -= give;
//         }
//     }
//     if(taken>0)
//         ans += taken*(taken+1)/2+taken*ret[numsSize-1];
//     return ans;
// }

int minIncrementForUnique(int* nums, int numsSize){
    int * ret=(int *)malloc(sizeof(int)*numsSize);
    for(int i=0;i<numsSize;i++)
        ret[i]=nums[i];
    qsort(ret, numsSize, sizeof(int), cmp);
    int move=0;
    for(int i=1; i<numsSize; i++){
        if(ret[i] <= ret[i-1]){
            int pre=ret[i];
            ret[i] = ret[i-1]+1;
            move += ret[i] - pre;
        }
    }
    return move;
}
```

### 9、[有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

```C
int cmp(const void *a, const void *b){
    return *(int *)a - *(int *)b;
}

int triangleNumber(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    int i,j,k, ans=0;
    for(i=0; i<numsSize; i++){
        j=i+1;
        k=j+1;
        while(j<numsSize){
            while(k<numsSize){
                if(nums[i]+nums[j] <= nums[k]){
                    break;
                }
                k++;
            }
            ans += k-j-1;
            j++;
            if(k == j)
                k++;
        }
    }
    return ans;
}
```

## leetcode刷题——07——二位数组

# 2022.03.12

### 1、[统计有序矩阵中的负数](https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/)

```C
int countNegatives(int** grid, int gridSize, int* gridColSize){
    int r=gridSize, l=gridColSize[0];
    int ans=0;
    for(int i=0; i<r; i++){
        for(int j=0; j<l; j++){
            if(grid[i][j]<0)
                ans++;
        }
    }
    return ans;
}
```

### 2、[矩阵对角线元素的和](https://leetcode-cn.com/problems/matrix-diagonal-sum/)

```C
int diagonalSum(int** mat, int matSize, int* matColSize){
    int r=matSize, l=matColSize[0];
    int result=0;
    for(int i=0; i<r; i++){
        result += mat[i][i] + mat[i][r-1-i];
    }
    if(r%2==1)
        result -= mat[r/2][r/2];
    return result;
}
```

### 3、[最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)

```C
int maximumWealth(int** accounts, int accountsSize, int* accountsColSize){
    int r=accountsSize;
    int max=0;
    for(int i=0; i<r; i++){
        int all=0;
        for(int j=0; j<accountsColSize[i]; j++)
            all += accounts[i][j];
        if(max < all)
            max=all;
    }
    return max;
}
```

### 4、[托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)

```C
bool isToeplitzMatrix(int** matrix, int matrixSize, int* matrixColSize){
    int r=matrixSize, l=matrixColSize[0];
    int i,j;
    for(i=0; i<l-1; i++)
        for(int tmp=i; tmp<l-1; tmp++)
            if(tmp-i<r-1)
                if(matrix[tmp-i][tmp] != matrix[tmp-i+1][tmp+1])
                    return false;
    for(j=1; j<r-1; j++)
        for(int tmp=j; tmp<r-1; tmp++)
            if(tmp-j<l-1)
                if(matrix[tmp][tmp-j] != matrix[tmp+1][tmp+1-j])
                    return false;
    return true;
}
```

### 5、[矩阵中的幸运数](https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/)

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int min(int a, int b){
    return a<b ? a : b;
}
int max(int a, int b){
    return a>b ? a : b;
}

int* luckyNumbers (int** matrix, int matrixSize, int* matrixColSize, int* returnSize){
    int r=matrixSize, c=matrixColSize[0];
    int *ret=(int *)malloc(sizeof(int)*r*c);
    *returnSize=2;
    int rmin[r], cmax[c];
    
    
    for(int i=0; i<r; i++){
        rmin[i]=matrix[i][0];
        for(int j=1; j<c; j++){
            rmin[i]=min(rmin[i], matrix[i][j]);
        }
    }
    for(int j=0; j<c; j++){
        cmax[j]=matrix[0][j];
        for(int i=1; i<r; i++){
            cmax[j]=max(cmax[j], matrix[i][j]);
        }
    }
    *returnSize = 0;
    for(int j=0; j<c; j++){
        for(int i=0; i<r; i++){
            if(rmin[i]==cmax[j])
                ret[ (*returnSize)++ ] = rmin[i]; 
        }
    }
    return ret;
}
```

### 6、[二进制矩阵中的特殊位置](https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/)

```C
int numSpecial(int** mat, int matSize, int* matColSize){
    int r=matSize, c=matColSize[0], ans=0;
    
    int rdata[r], cdata[c];
    for(int i=0; i<r; i++){		//筛选所有只包含一个1的行，并把1出现的位置加5后存在rdata[i]中
        rdata[i]=0;
        for(int j=0; j<c; j++)
            if(mat[i][j]==1)
                if(rdata[i]==0)
                    rdata[i]=j+5;
                else{
                    rdata[i]=0;
                    break;
                } 
    }
    
    for(int i=0; i<r; i++){
        int sum=0;
        if(rdata[i]){	//判断符合条件的行，是否满足所在列没有其他1的条件
            for(int j=0; j<r; j++)
                sum += mat[j][rdata[i]-5];
            if(sum != 1)
                sum = 0;
        }
        ans += sum;
    }
    return ans;        
}
```

### 7、[岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

```C
int islandPerimeter(int** grid, int gridSize, int* gridColSize){
    int r=gridSize+2, c=gridColSize[0]+2;

    int ** new=(int **)malloc(sizeof(int *) * r);
    for(int i=0; i<r; i++)
        *(new+i) = malloc(sizeof(int) * c);
    int i=0, j=0, ans=0;

    while(i<r){
        new[i][0]=0;
        new[i][c-1]=0;
        i++;
    }
    i=0;
    while(i<c){
        new[0][i]=0;
        new[r-1][i]=0;
        i++;
    }
    for( i=0; i<r-2; i++)
        for( j =0; j<c-2; j++)
            new[i+1][j+1]=grid[i][j];

    for(i=1; i < r-1; i++){
        for( j=1; j<c-1; j++){
            if(new[i][j])
                ans =ans + 4-(new[i-1][j] + new[i+1][j] + new[i][j-1] + new[i][j+1]);
        }
    }
    return ans;
}
```

# 2022.03.13

## leetcode刷题——08——二级指针



### LeetCode题目中二级指针的含义

```C
int** func(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
}
```

| 参数                | 变量类型 | 含义                                                         |
| ------------------- | -------- | ------------------------------------------------------------ |
| matrix              | 二级指针 | 传入的矩阵首地址                                             |
| matrixSize          | 普通变量 | 传入的矩阵的行数                                             |
| matrixColSize     | 一级指针 | 传入矩阵每行的列数（注意是每行，所以是数组）                 |
| returnSize        | 一级指针 | 传出矩阵的行数，由于需要作为参数返回，所以用指针取地址       |
| returnColumnSizes | 二级指针 | 传出矩阵的每行的列数，由于需要作为数组参数返回，所以用二级指针 |

### 二维数组的内存申请模板

```C
int **myMalloc(int r, int c, int* returnSize, int** returnColumnSizes) {
    int i;
    int **ret = (int **)malloc( sizeof(int *) * r );        // (1)
    *returnColumnSizes = (int *)malloc( sizeof(int) * r );  // (2)
    *returnSize = r;                                        // (3)
    for(i = 0; i < r; ++i) {
        ret[i] = (int *)malloc( sizeof(int) * c );          // (4)
        (*returnColumnSizes)[i] = c;                        // (5)
    }    
    return ret;
}
/*
(1) 申请一个矩阵（二维数组）的内存，行数为 r，首地址为ret，二维数组的类型为int **，二维数组中每个元素的类型为一级指针，即int *，对应sizeof(int *)这个表达式；
(2) 为这个矩阵的列申请一个数组来记录它每一行的列数，所以这个列数组的长度应该是行数r，由于需要作为参数返回给调用方，所以这里调用了一次解引用；
(3) *returnSize是需要返回的矩阵的行数，调用者不知道这个功能返回的矩阵有多少行，需要实现者告诉他，同样调用一次解引用；
(4) 申请矩阵每一行的内存空间，每一行的长度为c，即列数；
(5) 每一行的列数长度需要作为返回值返回，所以需要先解引用再索引到行号，即给(*returnColumnSizes)进行赋值；
*/
```

### 1、[翻转图像](https://leetcode-cn.com/problems/flipping-an-image/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int* returnSize, int** returnColumnSizes){
    int i;
    int ** ret = (int **)malloc(sizeof(int *) * r);
    *returnColumnSizes = (int *)malloc(sizeof(int) *r);
    *returnSize = r;
     for(i=0; i<r; i++){
         ret[i]=(int *)malloc(sizeof(int) * c);
         (*returnColumnSizes)[i] = c;
     }
     return ret;
}

int** flipAndInvertImage(int** image, int imageSize, int* imageColSize, int* returnSize, int** returnColumnSizes){
    int i,j;
    int r=imageSize, c=imageColSize[0];
    int ** ret=myMalloc(r, c, returnSize, returnColumnSizes);
    for(i=0; i<r; i++)
        for(j=0; j<c; j++)
            ret[i][j]=1-image[i][c-1-j];
    return ret;
}
```

### 2、[转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int *returnSize, int ** returnColumnSizes){
    int i;
    int ** ret=(int **)malloc(sizeof(int *)*r);
    *returnColumnSizes = (int *)malloc(sizeof(int)*r);
    *returnSize=r;

    for(i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int) * c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** transpose(int** matrix, int matrixSize, int* matrixColSize, int* returnSize, int** returnColumnSizes){
    int r=matrixSize, c=matrixColSize[0];
    int **ret=myMalloc(c, r, returnSize, returnColumnSizes);
    for(int i=0; i<c; i++)
        for(int j=0; j<r; j++){
            ret[i][j]=matrix[j][i];
        }
    return ret;
}
```

### 3、[重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** mymalloc(int r, int c, int *returnSize, int ** returnColumnSizes){
    *returnSize = r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int)*c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** matrixReshape(int** mat, int matSize, int* matColSize, int r, int c, int* returnSize, int** returnColumnSizes){
    int m = matSize, n = matColSize[0], id=0;
    int ** ret=mymalloc(r, c, returnSize, returnColumnSizes);
    if(n*m != r*c){
        *returnSize = m;
        for(int i=0; i<m; i++)
            (*returnColumnSizes)[i]=n;
        return mat;
    }


    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id=i*c+j;
            ret[i][j]=mat[id/n][id%n];
        }
    return ret;
}
```

### 4、[将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;    
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int **ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        ret[i]=(int *)malloc(sizeof(int)*c);
        (*returnColumnSizes)[i]=c;
    }
    return ret;
}
int** construct2DArray(int* original, int originalSize, int m, int n, int* returnSize, int** returnColumnSizes){
    int ** ret;
    if(n*m != originalSize){
        *returnSize=0;
        return ret;
    }
    ret=myMalloc(m, n, returnSize, returnColumnSizes);
    for(int i=0; i<m; i++)
        for(int j=0; j<n; j++)
            ret[i][j]=original[i*n+j];
    return ret;
}
```

### 5、[二维网格迁移](https://leetcode-cn.com/problems/shift-2d-grid/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=gridSize, c=gridColSize[0], id;
    int **ret = myMalloc(r, c, returnSize, returnColumnSizes);
    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id= i*c+j-k;
            while(id<0)
                id += r*c;
            ret[i][j]=grid[id/c][id%c];
        }
    return ret;
}

/*------------*/
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=gridSize, c=gridColSize[0], id;
    int **ret = myMalloc(r, c, returnSize, returnColumnSizes);
    k=k%(r*c);
    for(int i=0; i<r; i++)
        for(int j=0; j<c; j++){
            id= i*c+j-k;
            if(id<0)
                id += (r*c);
            ret[i][j]=grid[id/c][id%c];
        }
    return ret;
}
```

### 6、[图片平滑器](https://leetcode-cn.com/problems/image-smoother/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int **myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret=(int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int *)*c);
    }
    return ret;
}
int** imageSmoother(int** img, int imgSize, int* imgColSize, int* returnSize, int** returnColumnSizes){
    int r=imgSize, c=imgColSize[0];
    int ** ret=myMalloc(r, c, returnSize, returnColumnSizes);
    
    if(c>1 && r>1){
        for(int i; i<r; i++)
            for(int j=0; j<c; j++){
                //第一行
                if(i==0 && j==0)
                    ret[0][0]=(img[0][0]+img[0][1]+img[1][0]+img[1][1])/4;
                else if(i==0 && j==c-1)
                    ret[0][c-1]=(img[0][c-2]+img[0][c-1]+img[1][c-2]+img[1][c-1])/4;
                else if(i==0)
                    ret[0][j]=(img[0][j-1]+img[0][j]+img[0][j+1]+img[1][j-1]+img[1][j]+img[1][j+1])/6;
                //第一列
                else if(i<r-1 && j==0)
                    ret[i][0]=(img[i-1][0]+img[i][0]+img[i+1][0]+img[i-1][1]+img[i][1]+img[i+1][1])/6;
                //中间
                else if(i<r-1 && j>0 && j<c-1)
                    ret[i][j]=(img[i-1][j-1]+img[i-1][j]+img[i-1][j+1]+img[i+1][j-1]+img[i+1][j]+img[i+1][j+1]+img[i][j-1]+img[i][j]+img[i][j+1])/9;
                //最后一列
                else if(i<r-1 && j == c-1)
                    ret[i][c-1]=(img[i-1][c-1]+img[i][c-1]+img[i+1][c-1]+img[i-1][c-2]+img[i][c-2]+img[i+1][c-2])/6;
                //最后一行
                else if(i==r-1){
                    if(j==0)
                        ret[r-1][0]=(img[r-2][0]+img[r-2][1]+img[r-1][0]+img[r-1][1])/4;
                    else if(j == c-1)
                        ret[r-1][c-1]=(img[r-2][c-2]+img[r-2][c-1]+img[r-1][c-2]+img[r-1][c-1])/4;
                    else    
                        ret[r-1][j]=(img[r-1][j-1]+img[r-1][j]+img[r-1][j+1]+img[r-2][j-1]+img[r-2][j]+img[r-2][j+1])/6;

                }
            }
    }else if(r==1 && c==1){
        ret[0][0]=img[0][0];
    }else if(r==1){
        int i=0;
        for(int j=0; j<c; j++){
            if(j==0)
                ret[i][j]=(img[i][j]+img[i][j+1])/2;
            else if(j<c-1)
                ret[i][j]=(img[i][j-1]+img[i][j]+img[i][j+1])/3;
            else
                ret[i][j]=(img[i][j]+img[i][j-1])/2;
        }
    }else if(c==1){
        int j=0;
        for(int i=0; i<r; i++){
            if(i==0)
                ret[i][j]=(img[i+1][j]+img[i][j])/2;
            else if(i<r-1)
                ret[i][j]=(img[i-1][j]+img[i+1][j]+img[i][j])/3;
            else
                ret[i][j]=(img[i-1][j]+img[i][j])/2;
        }
    }

    return ret;
}
```

### 7、[矩阵区域和](https://leetcode-cn.com/problems/matrix-block-sum/)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** myMalloc(int r, int c, int * returnSize, int ** returnColumnSizes){
    *returnSize=r;
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);
    int ** ret = (int **)malloc(sizeof(int *)*r);
    for(int i=0; i<r; i++){
        (*returnColumnSizes)[i]=c;
        ret[i]=(int *)malloc(sizeof(int)*c);
    }
    return ret;
}
int the_sum(int** mat, int r, int c, int k, int i, int j){
    int sum=0, left=i-k, right=i+k, up=j-k, down=j+k;
    for(int p=0; p<r; p++)
        for(int q=0; q<c; q++)
            if(left<=p && p<=right && up<=q && q<=down)
                sum+=mat[p][q];
    return sum;
}
int** matrixBlockSum(int** mat, int matSize, int* matColSize, int k, int* returnSize, int** returnColumnSizes){
    int r=matSize, c=matColSize[0];
    int **ret=myMalloc(r, c, returnSize, returnColumnSizes);
    for(int i=0; i<r; i++){
        for(int j=0; j<c; j++){
            ret[i][j]=the_sum(mat, r, c, k ,i ,j);
        }
    }
    return ret;
}
```

### 8、[距离顺序排列矩阵单元格](https://leetcode-cn.com/problems/matrix-cells-in-distance-order/)

```C
int r0, c0;

int cmp(void* _a, void* _b) {
    int *a = *(int**)_a, *b = *(int**)_b;
    return fabs(a[0] - r0) + fabs(a[1] - c0) - fabs(b[0] - r0) - fabs(b[1] - c0);
}

int** allCellsDistOrder(int rows, int cols, int rCenter, int cCenter, int* returnSize, int** returnColumnSizes) {
    r0 = rCenter, c0 = cCenter;
    //分配空间
    int** ret = malloc(sizeof(int*) * rows * cols);
    *returnColumnSizes = malloc(sizeof(int) * rows * cols);
    for (int i = 0; i < rows * cols; i++) {
        (*returnColumnSizes)[i] = 2;
        ret[i] = malloc(sizeof(int) * 2);
    }

    *returnSize = 0;
    
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            ret[*returnSize][0] = i;
            ret[*returnSize][1] = j;
            (*returnSize)++;
        }
    }
    qsort(ret, rows * cols, sizeof(int*), cmp);
    return ret;
}
```

# 2022.03.14

## leetcode刷题——09——简单递归

### 1、[阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

```C
int trailingZeroes(int n){
    if(n<5)
        return 0;
    return n/5+trailingZeroes(n/5);
}
```

### 2、[将数字变成 0 的操作次数](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/)

```C
int numberOfSteps(int num){
    if(num==0)
        return 0;
    if(num%2)
        return numberOfSteps(num-1)+1;
    else
        return numberOfSteps(num/2)+1;
}
```

### 3、[完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

```C
int countNodes(struct TreeNode* root){
    if(root == NULL)
        return 0;
    return countNodes(root->left)+countNodes(root->right)+1;
}
```

### 4、[开幕式焰火](https://leetcode-cn.com/problems/sZ59z6/)

```C
int Hash[1024];

void transfer(struct TreeNode * root){
    if(root){
        Hash[root->val] = 1;
        transfer(root->left);
        transfer(root->right);
    }
}

int numColor(struct TreeNode* root){
    int i, sum=0;
    memset(Hash, 0, sizeof(Hash));
    transfer(root);
    for(i=0; i<=1000; i++)
        if(Hash[i])
            sum++;
    return sum;
}
```

### 5、[整数替换](https://leetcode-cn.com/problems/integer-replacement/)

```C
int sum=0;
int min(int a, int b){
    return a<b ? a: b;
}
int integerReplacement(int n){
    if (n==1)
            return 0;
        else
            if (n%2==0)
                return 1+integerReplacement(n/2);
            else
                return 2+min(integerReplacement(n/2+1),integerReplacement(n/2));
    return sum;
}
```

### 6、[二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

int sum, l, h;

void transfer(struct TreeNode *root){
    if(root){
        if(root->val >=l && root->val <= h)
            sum+=root->val;
            transfer(root->left);
            transfer(root->right);
    }
}
int rangeSumBST(struct TreeNode* root, int low, int high){
    l =low;
    sum=0;
    h=high;
    transfer(root);
    return sum;
}
```

### 7、[二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/),[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int max(int a, int b){
    return a>b ? a: b;
}

int maxDepth(struct TreeNode* root){
    if(root==NULL)
        return 0;
    return max(maxDepth(root->left), maxDepth(root->right))+1;
}
```

### 8、[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```C
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* invertTree(struct TreeNode* root) {
    if (root == NULL) {
        return NULL;
    }
    struct TreeNode* left = invertTree(root->left);
    struct TreeNode* right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
```

### 9、[所有路径](https://leetcode-cn.com/problems/bP4bmD/),[所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)(看不懂啊)

```C
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** ans;
int stk[15];
int stkSize;

void dfs(int x, int n, int** graph, int* graphColSize, int* returnSize, int** returnColumnSizes) {
    if (x == n) {
        int* tmp = malloc(sizeof(int) * stkSize);
        memcpy(tmp, stk, sizeof(int) * stkSize);
        ans[*returnSize] = tmp;
        (*returnColumnSizes)[(*returnSize)++] = stkSize;
        return;
    }
    for (int i = 0; i < graphColSize[x]; i++) {
        int y = graph[x][i];
        stk[stkSize++] = y;
        dfs(y, n, graph, graphColSize, returnSize, returnColumnSizes);
        stkSize--;
    }
}

int** allPathsSourceTarget(int** graph, int graphSize, int* graphColSize, int* returnSize, int** returnColumnSizes) {
    stkSize = 0;
    stk[stkSize++] = 0;
    ans = malloc(sizeof(int*) * 16384);
    *returnSize = 0;
    *returnColumnSizes = malloc(sizeof(int) * 16384);
    dfs(0, graphSize - 1, graph, graphColSize, returnSize, returnColumnSizes);
    return ans;
}
```

## C入门

### C_2.3、[和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)(迷迷糊糊)

```C
int** findContinuousSequence(int target, int* returnSize, int** returnColumnSizes){
    int r=target, c=target;
    int ** ret =(int **)malloc(sizeof(int *)*r);
    *returnColumnSizes=(int *)malloc(sizeof(int)*r);

        int i = 1, num=0;
        double j = 2.0;
        while(i < j) {
            j = (-1 + sqrt(1 + 4 * (2 * target + (long) i * i - i))) / 2;
            if(i < j && j == (int)j) {
                // vector<int> ans;                
                ret[num]=(int *)malloc(sizeof(int)*j);
                for(int k = i; k <= (int)j; k++){
                    ret[num][k-i]=k;
                }
                (*returnColumnSizes)[num]=j-i+1;
                num++;
            }
            i++;
        }
    *returnSize=num;
    return ret;
}
```

### C_4.1、[两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

```C
int divide(int dividend, int divisor){
    int signal = 1;
    unsigned int dvd = dividend;
    if (dividend < 0) {
        signal *= -1;
        dvd = ~dvd + 1;
    }

    unsigned int dvs = divisor;
    if (divisor < 0) {
        signal *= -1;
        dvs = ~dvs + 1;
    }

    int shift = 0;
    while (dvd > dvs << shift) {
        shift++;
    }

    unsigned int res = 0;
    while (dvd >= dvs) {
        while (dvd < dvs << shift) {
            shift--;
        }
        res |= (unsigned int) 1 << shift;
        dvd -= dvs << shift;
    }

    if (signal == 1 && res >= INT_MAX) {
        return INT_MAX;
    } else {
        return res * signal;
    }
}
```

# 2022.03.15

### C_7.1、[阶乘尾数](https://leetcode-cn.com/problems/factorial-zeros-lcci/)

```c
int trailingZeroes(int n){
    int count = 0;
    while(n >= 5){
        n /= 5;
        count += n;
    }
    return count;
}
```

### C_7.2、[阶乘函数后 K 个零](https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/)

```C
/*
     * 按照数据规律求解
     * 阶乘
     * 1个5      5   1
     * 2个5 =    25  6   实际相当于 5个1个5，然后再加25自身是两个5，所以得到的是 5+1 = 6
     * 3个5 =    125 31  相当于5个25，然后加自身125又多了一个5 所以的（5+1）*5+1=31
     * 按照这个规律，则后续公式可以f(2)=f(1)*5+1 f(1)=1 则 f(x+1) = f(x)*5+1  x是5的次幂数
*/
int preimageSizeFZF(int k){
    //确定阶梯值范围 最终的到的K < start
        int start = 1;
        while (start < k){
            start = start*5+1;
        }
        //确定范围后，执行精确查找
        while (start > 1){
            //只有5以下阶乘才会出现start-1成立，其它情况不会存在，因为任何一个阶段分界值都会包含一个以上的5
            if(start-1 == k){
                //不存在的返回0
                return 0;
            }
            //逆推下一个阶梯值 从f(x+1) 推导出f(x)
            start=(start-1)/5;

            //获取剩余值，进行下一阶梯运算
            k%=start;
        }
        //只要存在，必然是5个
        return 5;
}
```

### C_8.1、[转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/)

```c
char * toLowerCase(char * s){
    char *ret;
    ret = (char *)malloc(sizeof(char)*101);
    int i=0;
    int tmp='A'-'a';
    while(s[i] != '\0'){
        if(s[i]>='A' && s[i] <='Z')            
            ret[i]=s[i]-tmp;
        else 
            ret[i]=s[i];
        i++;
    }
    ret[i]='\0';
    return ret;
}
```

### C_8.2、[检测大写字母](https://leetcode-cn.com/problems/detect-capital/)

```c
bool detectCapitalUse(char * word){
    int i=1;
    int flag=0;
    if(word[0]>='A' && word[0]<='Z'){
        flag=1;
        if(word[1]!='\0' && word[1]>='a' && word[1]<='z')
            flag=3;
    }
    else if(word[0]>='a' && word[0]<='z')
        flag=2;
    while(word[i] != '\0'){
        if(flag==2||flag==3)
            if(word[i]<'a' || word[i]>'z'){
                flag=0;
                break;
            }
        if(flag==1){
             if(word[i]<'A' || word[i]>'Z'){
                flag=0;
                break;
            }
        }
        i++;
    }

    return flag;
}
```

### C_9.1、[最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

```c
int max(int a, int b){
    return a>b ? a: b;
}

int findMaxConsecutiveOnes(int* nums, int numsSize){
    // numsSize = 0;
    int i=0;
    int ret=0, now_num=0;
    while(i<numsSize){
        if(nums[i])
            now_num++;
        else{
            ret=max(ret,now_num);
            now_num=0;
        }
        i++;
    }
    ret=max(ret,now_num);
    return ret;
}
```

### C_9.2、[数组中两元素的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/)

```c
int cmp(const void * a, const void * b){
    return *(int *)a - *(int *)b;
} 
int maxProduct(int* nums, int numsSize){
    qsort(nums, numsSize, sizeof(int), cmp);
    return (nums[numsSize-1]-1)*(nums[numsSize-2]-1);
}
```

### C_10.1、[子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)

```c
double max(double a, double b){
    return a>b ? a: b;
}
double findMaxAverage(int* nums, int numsSize, int k){
    double the_max=0, tmp=0;
    int sum=0;
    for(int i=0; i<k; i++)
        sum+=nums[i];
    tmp=sum;
    the_max=tmp*1.0/k;

    for(int i=1; i<=numsSize-k; i++){
        sum=sum-nums[i-1]+nums[i+k-1];
        tmp=sum;
        tmp=tmp*1.0/k;
        the_max=max(the_max, tmp);
    }
    return the_max;
        
}
```

### S_2.4、[单调数列](https://leetcode-cn.com/problems/monotonic-array/)

```c
bool isMonotonic(int* nums, int numsSize){
    int flag1=0, flag2=0;
    for(int i=1; i<numsSize; i++){
        if(nums[i] > nums[i-1])
            flag1=1;
        if(nums[i] < nums[i-1])
            flag2=1;
    }
    if(flag2+flag1==2)
        return false;
    else
        return true;
}
```

### S_2.5、[解压缩编码列表](https://leetcode-cn.com/problems/decompress-run-length-encoded-list/)

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* decompressRLElist(int* nums, int numsSize, int* returnSize){
    int * ret=(int *)malloc(sizeof(int)*100*100);
    int all=0;
    for(int i=0; i<numsSize; i=i+2){
        for(int j=0; j<nums[i]; j++)
            ret[all++]=nums[i+1];
    }
    *returnSize = all;
    return ret;
}
```

### S_2.7、[连续整数求和](https://leetcode-cn.com/problems/consecutive-numbers-sum/)(看不懂)

```c
int consecutiveNumbersSum(int N){;
        while ((N & 1) == 0) N >>= 1;
        int ans = 1, d = 3;

        while (d * d <= N) {
            int e = 0;
            while (N % d == 0) {
                N /= d;
                e++;
            }
            ans *= e + 1;
            d += 2;
        }

        if (N > 1) ans <<= 1;
        return ans;
}
```

### S_3.4、[旋转图像](https://leetcode-cn.com/problems/rotate-image/)

```c
void rotate(int** matrix, int matrixSize, int* matrixColSize){
    int n= matrixSize;
    // 转置
    for(int i=0; i<n; i++)
        for(int j=i+1; j<n; j++){
            int tmp=matrix[i][j];
            matrix[i][j]=matrix[j][i];
            matrix[j][i]=tmp;
        }
    // 镜像 
    for(int i; i<n; i++)
        for(int j=0; j<n/2; j++){
            int tmp=matrix[i][j];
            matrix[i][j]=matrix[i][n-1-j];
            matrix[i][n-1-j]=tmp;
        }

}
```

### S_3.7、[判断矩阵经轮转后是否一致](https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/)

```c
bool findRotation(int** mat, int matSize, int* matColSize, int** target, int targetSize, int* targetColSize){
    
    int n=matSize, flag=0;
    for(int i=0; i<n; i++)
        for(int j=0; j<n; j++)
            if(target[i][j] != mat[i][j]){
                flag=1;
                break;
            }  
    // 顺时针90
    if(flag==1)
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(target[i][j] != mat[n-1-j][i]){
                    flag=2;
                    break;
                }         
        // 180
    if(flag==2)
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(target[i][j] != mat[n-1-i][n-1-j]){
                    flag=3;
                    break;
                }
    // // 逆时针90
    if(flag==3)
        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(target[i][j] != mat[j][n-1-i]){
                    flag = 4;
                    break;
                }
    if(flag == 4 )
        return false;       
         
    return true;
}
```

### S_3.9、[螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)(迷迷糊糊)

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int* spiralOrder(int** matrix, int matrixSize, int* matrixColSize, int* returnSize) {
    if (matrixSize == 0 || matrixColSize[0] == 0) {
        *returnSize = 0;
        return NULL;
    }

    int rows = matrixSize, columns = matrixColSize[0];
    int visited[rows][columns];
    memset(visited, 0, sizeof(visited));
    int total = rows * columns;
    int* order = malloc(sizeof(int) * total);
    *returnSize = total;

    int row = 0, column = 0;
    int directionIndex = 0;
    for (int i = 0; i < total; i++) {
        order[i] = matrix[row][column];
        visited[row][column] = true;
        int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
        if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
            directionIndex = (directionIndex + 1) % 4;
        }
        row += directions[directionIndex][0];
        column += directions[directionIndex][1];
    }
    return order;
}
```

# 2022.03.16

### S_4.1、[杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generate(int numRows, int* returnSize, int** returnColumnSizes){
    int ** ret=(int **)malloc(sizeof(int *)*numRows);
    *returnSize = numRows;
    *returnColumnSizes=(int *)malloc(sizeof(int)*numRows);
    for(int i=0; i<numRows; i++){
        ret[i]=(int *)malloc(sizeof(int)*(i+1));
        (*returnColumnSizes)[i]=i+1;
        for(int j=0; j<i+1; j++){
            if(j==0 || i==j)
                ret[i][j]=1;
            else
                ret[i][j] = ret[i-1][j] + ret[i-1][j-1]; 
        }
    }
    return ret;
}
```

### S_4.2、[杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* getRow(int rowIndex, int* returnSize){
    int numRows=rowIndex+1;
    int ** ret=(int **)malloc(sizeof(int *)*numRows);
    *returnSize = numRows;
    int i;
    for(i=0; i<numRows; i++){
        ret[i]=(int *)malloc(sizeof(int)*(i+1));
        for(int j=0; j<i+1; j++){
            if(j==0 || i==j)
                ret[i][j]=1;
            else
                ret[i][j] = ret[i-1][j] + ret[i-1][j-1]; 
        }
    }
    return ret[i-1];
}
```

### S_5.1、[唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/)

```cc
int cnt[101];
int sumOfUnique(int* nums, int numsSize){
    memset (cnt, 0, sizeof(cnt));
    int sum=0; 
    for(int i=0; i<numsSize; i++)
        cnt[nums[i]]++;
    for(int i=0; i<101; i++)
        if(cnt[i]==1)
            sum += i;
    return sum;
}   
```

### S_5.2、[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

```c
struct data{
    int num;
    int place;
}Data[256];
int min(int a, int b){
    return a<b ? a: b;
}
int firstUniqChar(char * s){
    for(int i=0; i<256; i++)
        Data[i].num=0;
    int place=-1;
    for(int i=0; s[i]!='\0'; i++){
        Data[s[i]].num++;
        Data[s[i]].place=i;
    }
    int least=100000;
    for(int i=0; i<256; i++){
        if(Data[i].num==1)
            least=min(least, Data[i].place);
    }
    if(least == 100000)
        return -1;
    else 
        return least;
}
```

### S_5.3、[检查是否所有字符出现次数相同](https://leetcode-cn.com/problems/check-if-all-characters-have-equal-number-of-occurrences/)

```c
bool areOccurrencesEqual(char * s){
    int * cnt[26];
    memset(cnt, 0, sizeof(cnt));

    for(int i=0; s[i]!='\0'; i++){
        cnt[s[i]-'a']++;
    }
        
    int last = s[0]-'a';
    for(int i=0; i< 26; i++)
        if(cnt[i]>0)
            if(cnt[i] != cnt[last])
                return false;
    return true;
}
```

# 2022.03.17

### S_5.4、[找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){
    int cnt[numsSize+1];
    int *ret=(int *)malloc(sizeof(int)*numsSize);
    memset(cnt, 0, sizeof(cnt));
    for(int i=0; i<numsSize; i++)
        cnt[nums[i]]++;
    int j=0;
    for(int i=1; i<=numsSize; i++)
        if(cnt[i]==0){
            ret[j]=i;
            j++;
        }
    *returnSize=j;
    return ret;
}
```

### S_5.5、[好数对的数目](https://leetcode-cn.com/problems/number-of-good-pairs/)

```c
int numIdenticalPairs(int* nums, int numsSize){
    int cnt[101];
    memset(cnt, 0, sizeof(cnt));
    for(int i=0; i< numsSize; i++)
        cnt[nums[i]]++;
    int sum=0;
    for(int i=1; i<101; i++)
        if(cnt[i]>1)
            sum += (cnt[i]*(cnt[i]-1))/2;
    return sum;
}
```

### S_5.6、[大餐计数](https://leetcode-cn.com/problems/count-good-meals/)

```c
int cnt[ (1<<21) + 1 ];
int countPairs(int* deliciousness, int deliciousnessSize){
    int i, sum = 0;
    int ans = 0;
    memset (cnt, 0, sizeof(cnt));                    // (1)

    for(i = 0; i < deliciousnessSize; ++i) {         // (2)
        for(sum = 1; sum <= (1<<21); sum *= 2) {     // (3)
            int other = sum - deliciousness[i];          // (4)
            if (other < 0) {                         // (5) 
                continue;
            }
            ans += cnt[ other ];                     // (6)
            ans %= 1000000007;
        }
        ++ cnt[ deliciousness[i] ];                  // (7)
    }
    return ans;                                      // (8)
}
```

### S_6.1、[一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)

```c
// 蔡勒(Zeller)公式 https://www.cnblogs.com/faterazer/p/11393521.html
char * dayOfTheWeek(int day, int month, int year){
    char * week[7] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
    int monthDays[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};
    /* 输入年份之前的年份的天数贡献 */
    int days = 365 * (year - 1971) + (year - 1969) / 4;
    /* 输入年份中，输入月份之前的月份的天数贡献 */
    for (int i = 0; i < month - 1; ++i) {
        days += monthDays[i];
    }
    if ((year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) && month >= 3) {
        days += 1;
    }
    /* 输入月份中的天数贡献 */
    days += day;
    return week[(days + 3) % 7];
}
```

### S_6.2、[一年中的第几天](https://leetcode-cn.com/problems/day-of-the-year/)

```c
bool isLeapYear(int y){
    return (y%4==0 && y%100) || (y%400==0);
}
int strToInt(char *str, int len){
    int i, sum=0;
    for(i=0; i<len; i++)
        sum=sum*10+(str[i]-'0');
    return sum;
}
int dayOfYear(char * date){
    int monthday[]={0, 
        31, 28, 31, 30, 31, 30,
        31, 31, 30, 31, 30, 31};
    int sumday[13], i;
    int year, month, day;
    year=strToInt(date+0, 4);
    month=strToInt(date+5, 2);
    day=strToInt(date+8, 2);
    monthday[2] = isLeapYear(year) ? 29 : 28;
    sumday[0]=0;
    for(int i=1; i<month; i++)
        sumday[i] = sumday[i-1] + monthday[i];
    return sumday[month-1]+day;
}
```

### S_6.3、[日期之间隔几天](https://leetcode-cn.com/problems/number-of-days-between-two-dates/)

```c
bool isLeapYear(int y){
    return (y%4==0 && y%100) || (y%400==0);
}
int strToInt(char *str, int len){
    int i, sum=0;
    for(i=0; i<len; i++)
        sum=sum*10+(str[i]-'0');
    return sum;
}
int nums(char *date){
    int monthday[]={0, 
        31, 28, 31, 30, 31, 30,
        31, 31, 30, 31, 30, 31};
    int year, month, day;
    year=strToInt(date+0, 4);
    month=strToInt(date+5, 2);
    day=strToInt(date+8, 2);
    int num=0;
    for(int i=1971; i<year; i++)
        if(isLeapYear(i))
            num+=366;
        else
            num+=365;
    for(int i=0; i<month; i++){
        if(i==2)
            monthday[2] = isLeapYear(year) ? 29 : 28;
        num += monthday[i];
    }
    num += day;    
    return num;
}
int daysBetweenDates(char * date1, char * date2){
    int num1=nums(date1);
    int num2=nums(date2);
    return num1>num2 ? num1-num2 : num2-num1;
}
```

### S_7.1、[回文素数](https://leetcode-cn.com/problems/prime-palindrome/)

```c
```

### S_7.2、[丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

```c

```

# 2022.03.18

## 链表

**结点结构体**

```c
typedef int DataType;
struct ListNode {
    DataType data;  // (1) 数据域：可以是任意类型，由编码的人自行指定
    ListNode *next; // (2) 指针域：指向 后继结点 的地址；
};
```

**创建结点**

```c
ListNode *ListCreateNode(DataType data) {
    ListNode *node = (ListNode *) malloc ( sizeof(ListNode) ); // (1) 系统库函数malloc分配一块内存空间，用来存放ListNode即链表结点对象
    node->data = data;		// (2) 将 数据域 置为函数传参data；
    node->next = NULL;		// (3) 将 指针域 置空，代表这是一个孤立的 链表结点；
    return node;			// (4) 返回这个结点的指针。
}
```

### 链表的创建 - 尾插法

记录一个 **链表尾结点**，然后遍历给定数组，将数组元素一个一个插到链表的尾部，每插入一个结点，则将它更新为新的 **链表尾结点**。注意初始情况下，**链表尾结点** 为空。

```c
ListNode *ListCreateListByTail(int n, int a[]) {
    ListNode *head, *tail, *vtx;    // tail     
    // (1) head存储头结点的地址，tail存储尾结点的地址，vtx存储当前正在插入结点的地址；
    int idx;                              
    if(n <= 0)
        return NULL;                     
    // (2) 当需要创建的元素个数为 0 时，直接返回空链表；
    idx = 0;
    vtx = ListCreateNode(a[0]);          
    // (3) 创建一个 数据域 为a[0]的链表结点；
    head = tail = vtx;                   
    // (4) 由于初始情况下只有一个结点，所以将链表头结点head和链表尾结点tail都置为vtx；
    while(++idx < n) {                   
    // (5) 从数组第 1 个元素 (0 - based) 开始，循环遍历数组；
        vtx = ListCreateNode(a[idx]);    
        // (6) 由于数组中第 0 个元素已经创建过了，所以这里只需要对除了第 0 个元素以外的数据创建链表结点；
        tail->next = vtx;                
        // (7) 结点创建出来后，将当前链表尾结点tail的 后继结点 置为vtx；
        tail = vtx;                      
        // (8)将最近创建的结点vtx作为新的 链表尾结点；
    } 
    return head;                         
    // (9) 返回链表头结点；
} 
```

### 链表的创建 - 头插法

```c
ListNode *ListCreateListByHead(int n, int *a) {
    ListNode *head = NULL, *vtx;       
    // (1) head存储头结点的地址，初始为空链表， vtx存储当前正在插入结点的地址；
    while(n--) {                       
    // (2) 总共需要插入 n nn 个结点，所以采用逆序的 n nn 次循环；
        vtx = ListCreateNode(a[n]);    
        // (3) 创建一个元素值为a[i]的链表结点，注意，由于逆序，所以这里 i的取值为 n−1 → 0；
        vtx->next = head;              
        // (4) 将当前创建的结点的 后继结点 置为 链表的头结点head；
        head = vtx;                    
        // (5) 将链表头结点head置为vtx；
    } 
    return head;                       
    // (6) 返回链表头结点；
} 
```

### 打印链表

```c
void ListPrint(ListNode *head) {
    ListNode *vtx = head;
    while(vtx) {                      // (1) 从头结点开始，循环遍历所有结点；
        printf("%d -> ", vtx->data);  // (2) 遍历到的结点，将结点的 数据域 带上->后输出;
        vtx = vtx->next;              // (3) 将 当前结点 置为 当前结点 的 后继结点，继续迭代；
    }
    printf("NULL\n");                 // (4) 最后输出一个NULL，代表一个完整的链表；
}
```

### 链表元素的索引

给定一个链表头结点head，并且给定一个索引值 i ( i ≥ 0 )，求这个链表的第 i 个结点

```c
ListNode *ListGetNode(ListNode *head, int i) {
    ListNode *temp = head;       
    // (1) temp代表从链表头开始的 游标指针，用于对链表进行 遍历 操作；
    int j = 0;                   
    // (2) j代表当前访问到了第 j 个结点；
    while(temp && j < i) {       
        // (3) 如果 游标指针 非空，并且j < i，则代表还没访问到目标结点，继续执行循环；
        temp = temp->next;       
        // (4) 将 游标指针 的 后继结点 作为新一轮的 游标指针，继续迭代；
        ++j;                     
        // (5) j自增，等价于j = j + 1;
    }
    if(!temp || j > i) {
        return NULL;             
        // (6) 当 游标指针 为空，或者j > i，则说明给定的i超过了链表长度，返回 空结点；
    }
    return temp;                 
    // (7) 最后，返回找到的第i个结点；
}
```

索引结点的操作，最坏情况下需要遍历整个链表，所以时间复杂度为 $O(n)$。

整个索引过程只记录了两个变量：**游标结点** 和 **当前索引值**。和链表长度无关，所以空间复杂度为$O(1)$。

### 链表元素的查找

给定一个链表头head，并且给定一个值 v ，查找出这个链表上 数据域 等于 v 的第一个结点。

```c
ListNode *ListFindNodeByValue(ListNode *head, DataType v) {
    ListNode *temp = head;       // (1) temp代表从 链表头 开始遍历的 游标指针；
    while(temp) {                // (2) 如果 游标指针 非空，继续循环 ；
        if(temp->data == v) {
            return temp;         // (3) 一旦发现 数据域 和 给定的 参数v相等，立即返回该结点对应的指针；
        } 
        temp = temp->next;       // (4) 否则，将 游标指针 的 后继结点 作为新一轮的 游标指针，继续迭代；
    }
    return NULL;                 // (5) 一直到链表尾都找不到，返回 NULL；
}
```

查找结点的操作，最坏情况下就是找不到，需要遍历整个链表，所以时间复杂度为 $O(n)$。

整个查找过程只记录了一个变量：游标指针。和链表长度无关，所以空间复杂度为$O(1)$。

### 链表结点的插入

给定一个链表头head，并且给定一个位置 i ( i ≥ 0 ) 和 一个值 v ，求生成一个值为 v 的结点，并且将它插入到 链表 第 i 个结点之后。

```C
ListNode *ListInsertNode(ListNode *head, int i, DataType v) {
    ListNode *pre, *vtx, *aft;                     
    // (1) 预先定义三个指针，当结点插入完毕后， pre -> vtx -> aft；
    int j = 0;                                     
    // (2) 定义一个计数器，当 j == i时，表明找到要插入的位置；
    pre = head;                                    
    // (3) 从 链表头结点 开始迭代遍历链表；
    while(pre && j < i) {                          
    // (4) 如果还没有到链表尾，或者没有找到插入位置则继续循环；
        pre = pre->next;                           
        // (5) 将 游标指针 的 后继结点 作为新一轮的 游标指针，继续迭代；
        ++j;                                       
        // (6) 计数器加 1；
    }
    if(!pre) { 
        return NULL;                               
        // (7) 元素个数不足，无法找到给定位置，返回 NULL；
    }
    vtx = ListCreateNode(v);                       
    // (8) 创建一个值为v的 孤立结点；
    aft = pre->next;                               // (9)
    vtx->next = aft;                               // (10)
    pre->next = vtx;                               // (11)
    // (9)→(11) 这三步就是为了将vtx插入到pre -> aft之间，插入完毕后pre -> vtx -> aft。
    return vtx;                                    
    // (12) 最后，返回插入的那个结点；
}
```

虽然插入操作本身是 $O(1)$的，但是这里有一步 索引结点 的操作，最坏情况下就是找不到对应的结点，需要遍历整个链表，所以时间复杂度为 $O(n)$。

整个查找和插入的过程只记录了三个变量，和链表长度无关，所以空间复杂度为$O(1)$。

### 链表结点的删除

给定一个链表头head，并且给定一个位置 i ( i ≥ 0 )，将位置为 i 的结点删除，并且返回新链表的头结点（为什么要返回头结点？因为被删掉的有可能是原来的头结点）。

```c
ListNode *ListDeleteNode(ListNode *head, int i) {
    ListNode *pre, *del, *aft;
    int j = 0;
    if(head == NULL) {
        return NULL;              // (1) 空链表，无法执行删除，直接返回； 
    }
    if(i == 0) {                  // (2) 需要删除链表第 0 个结点；
        del = head;               // (3) 缓存第 0 个结点；      
        head = head->next;        // (4) 将新的 链表头结点 变为 当前头结点 的 后继结点； 
        free(del);                // (5) 调用系统库函数free释放内存；
        return head;              // (6) 返回新的 链表头结点； 
    }
    
    pre = head;                   // (7) 从 链表头结点 开始遍历链表； 
    while(pre && j < i - 1) {     // (8) 找到将要被删除结点的 前驱结点pre； 
        pre = pre->next;
        ++ j;
    }
    if(!pre || !pre->next) {      // (9) 如果 前驱结点 为空，或者 需要删除的结点 为空，则直接返回当前 链表头结点；
        return head;
    }
    del = pre->next;              // (10) 缓存需要删除的结点到del；
    aft = del->next;              // (11) 缓存需要删除结点的后继结点到aft；
    pre->next = aft;              // (12) 将需要删除的结点的前驱结点指向它的后继结点；
    free(del);                    // (13) 释放需要删除结点的内存空间；
    return head;                  // (14) 返回链表头结点；
} 
```

删除结点本身的时间复杂度为$O(1)$。但是由于需要查找到需要删除的结点，所以总的时间复杂度还是$O(n) $的。

不需要用到额外空间，所以总的时间复杂度为$O(1)$。

### 链表的销毁

需要将 **所有结点** 的内存空间进行释放，并且需要将 **链表的头结点** 置空。可以理解成不断删除第 0 号结点的过程，直到链表头为空位置，只是一个循环调用。

```c
void ListDestroyList(ListNode **pHead) { 
// (1) 这里必须用二级指针，因为删除后需要将链表头置空，普通的指针传参无法影响外部指针变量； 
    ListNode *head = *pHead;             
    // (2) 给 链表头结点 解引用，即通过 链表头结点的地址 获取 链表头结点；
    while(head) {                        
    // (3) 如果链表非空，则继续循环
        head = ListDeleteNode(head, 0);  
    // (4) 每次迭代，删除 链表头结点，并且返回其 后继结点 作为新的 链表头结点；
    }
    *pHead = NULL;                       
    // (5) 最后，将 链表头结点 置空，这样当函数返回时，传参的head才能是NULL，否则外部会得到一个内存已经释放了的 野指针；
}
```

### 链表的优缺点

**1、优点**

内存分配：
  由于是链式存储，随时增加元素随时分配内存，不需要像数组那样进行预分配存储空间；
插入：
  当拥有链表某个结点的指针时，在它 后继位置 插入一个新的结点的的时间复杂度为$O(1)$；
删除：
  当拥有链表某个结点的指针时，删除它的 后继结点 的时间复杂度为 $O(1)$；

**2、缺点**

索引：
  索引第几个结点时，时间复杂度为$O(n)$；
查找：
  查找是否存在某个结点时，时间复杂度为$O(n)$；

# 2022.03.19

### [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* reverseList(struct ListNode* head){
    struct ListNode *new=NULL, *pre = head;
    while(pre != NULL){
        struct ListNode *next=pre->next;
        pre->next = new;
        new = pre;
        pre = next;
    }
    return new;
/*
    struct ListNode* cur = NULL, *pre = head;   // 定义一个空结点指针，代表当前结点， 定义前驱结点指向头结点
    while (pre != NULL) {
        struct ListNode* t = pre->next; // 定义临时结点，是前驱结点后一个结点
        pre->next = cur;    // 前驱结点指向上一次的当前结点
        cur = pre;      // 当前结点为前驱结点
        pre = t;    // 将前驱的下一个结点赋值为前驱结点
    }
    return cur;*/
}
```

## 蓝桥杯相关

1、STM32CubeMX配置时钟

![QQ截图20220319201706](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773894.png)

![QQ截图20220319201840](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773892.png)

### 程序设计流程

#### 1.利用STM32CUBEMX生成工程框架

![QQ截图20220320143521](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773890.png)

![QQ截图20220320143834](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773888.png)

![QQ截图20220320143941](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773885.png)

![QQ截图20220320144036](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773829.png)

![QQ截图20220320144329](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773803.png)

![QQ截图20220320144346](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773801.png)

![QQ截图20220320145208](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773799.png)

在`MDK-ARM`文件夹下可能缺少启动文件`startup_stm32g431xx.s`导致工程无法编译，可以在官方提供的例程中copy过来

![QQ截图20220320145602](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773797.png)

![QQ截图20220320145645](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773794.png)

将工程的所有文件拷贝到`Project_Source`中，作为以后的模板

![QQ截图20220320145852](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773791.png)

![QQ截图20220320145946](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773789.png)

#### 2.利用STM32CUBEMX生成初始化代码文件

配置模板的GPIO

使用Cube MX重新打开配置文件

![QQ截图20220320150416](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773786.png)

通过CubeMX设置GPIO端口

![QQ截图20220320150705](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773784.png)

![QQ截图20220320150922](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773782.png)

PD2默认为低电平

![QQ截图20220320151029](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773780.png)

#### 3.开发板测试

回到`HLL_LET_01`的工程中

添加中间层文件夹，创建相关文件

`HLL_LET_01\Src\bsp\led\bsp_led.c`和`HLL_LET_01\Inc\bsp\led\bsp_led.h`

删除`gpio.c`和`gpio.h`，并在工程中移除

![QQ截图20220320152325](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773727.png)

在工程中添加中间层文件夹`BSP`

![QQ截图20220320152719](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647773722.png)

在工程中添加中间层头文件的位置

![QQ截图20220320153010](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647764680.png)

往`bsp\led\bsp_led.c`移植代码

将`main.c`中的`//#include "gpio.h"`改为`#include "led\bsp_led.h"`，在`bsp_led.h`中写入

```c
#include "main.h"
void LED_Init(void);
```

在`bsp_led.c`中写入(将`Project_Source`工程中`gpio.c`的初始化代码拷贝过来，并修改函数名`MX_GPIO_Init`为`LED_Init`)

```c
#include "led\bsp_led.h"

void LED_Init(void)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_8
                          |GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);

  /*Configure GPIO pins : PC13 PC14 PC15 PC8
                           PC9 PC10 PC11 PC12 */
  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_8
                          |GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : PD2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

}
```

修改`main.c`点亮led灯

```c
  while (1)
  {
    /* USER CODE END WHILE */
	// HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);	// gpio15置0
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); 	// 打开PD2 
	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
    /* USER CODE BEGIN 3 */
  }
```

## 借助*upgit*实现Typora自动上传图片

1、下载`upgit` ，https://github.com/pluveto/upgit

2、在https://github.com/settings/tokens设置为`upgit`专用的`token`

3、编写`upgit`的配置文件`config.toml`

```yaml
rename = "{year}/{month}/upgit_{year}{month}{day}_{unix_ts}{ext}"
[uploaders.github]
pat = "ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
repo = "repo-name"
username = "username"
```

4、配置`typora`

![upgit](https://raw.githubusercontent.com/simoonp/upgit_picture/main/2022/03/upgit_20220320_1647765700.png)

